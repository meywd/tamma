# Story 2.8: Pull Request Creation

**Epic**: Epic 2 - Autonomous Development Loop - Core  
**Status**: Ready for Development  
**Priority**: High  
**Prerequisites**: Story 2.7 (code refactoring must complete first)

---

## ‚ö†Ô∏è MANDATORY: Before You Code

**ALL contributors MUST read and follow the comprehensive development process:**

üìñ **[BEFORE_YOU_CODE.md](../../BEFORE_YOU_CODE.md)**

This mandatory guide includes:
- 7-Phase Development Workflow (Read ‚Üí Research ‚Üí Break Down ‚Üí TDD ‚Üí Quality Gates ‚Üí Failure Handling)
- Knowledge Base Usage (.dev/ directory: spikes, bugs, findings, decisions)
- TRACE/DEBUG Logging Requirements for all functions
- Test-Driven Development (TDD) mandatory workflow
- 100% Test Coverage requirement
- Build Success enforcement
- Automatic retry and developer alert procedures

**Failure to follow this process will result in rework.**

---

## User Story

As a **developer**,
I want the system to create a pull request with comprehensive description and metadata,
So that code changes can be reviewed and merged through standard workflow.

---

## Acceptance Criteria

1. System creates pull request from feature branch to target branch
2. PR includes comprehensive description with issue context and implementation details
3. PR includes automated labels, reviewers, and project metadata
4. PR description includes test results, coverage metrics, and change summary
5. System validates PR creation was successful
6. PR creation and metadata logged to event trail
7. Integration test validates PR creation workflow
8. Error handling for permission issues, conflicts, and API failures

---

## Technical Context

### ‚ö†Ô∏è Development Process Reminder

**Before implementing this story, ensure you have:**
1. ‚úÖ Read [BEFORE_YOU_CODE.md](../../BEFORE_YOU_CODE.md)
2. ‚úÖ Searched `.dev/` directory for related spikes, bugs, findings, and decisions
3. ‚úÖ Reviewed relevant documentation in `docs/` directory
4. ‚úÖ Checked existing code patterns for similar functionality
5. ‚úÖ Planned TDD approach (Red-Green-Refactor cycle)


### Core Components

**PullRequestCreator Service**:

```typescript
interface IPullRequestCreator {
  createPR(plan: DevelopmentPlan, result: ImplementationResult): Promise<PullRequest>;
  generatePRDescription(
    plan: DevelopmentPlan,
    result: ImplementationResult
  ): Promise<PRDescription>;
  assignReviewers(pr: PullRequest, plan: DevelopmentPlan): Promise<void>;
  addLabels(pr: PullRequest, plan: DevelopmentPlan): Promise<void>;
  linkIssues(pr: PullRequest, plan: DevelopmentPlan): Promise<void>;
  validatePRCreation(pr: PullRequest): Promise<boolean>;
}

interface PullRequest {
  id: string;
  number: number;
  title: string;
  description: string;
  url: string;
  state: 'open' | 'closed' | 'merged';
  author: string;
  baseBranch: string;
  headBranch: string;
  repository: RepositoryInfo;
  createdAt: Date;
  updatedAt: Date;
  mergeable?: boolean;
  draft?: boolean;
  reviewers: string[];
  labels: string[];
  linkedIssues: string[];
  metadata: PRMetadata;
}

interface PRDescription {
  title: string;
  body: string;
  summary: string;
  changes: ChangeSummary;
  testing: TestingSummary;
  metadata: DescriptionMetadata;
}

interface ChangeSummary {
  filesAdded: number;
  filesModified: number;
  filesDeleted: number;
  linesAdded: number;
  linesDeleted: number;
  binaryFiles: number;
  fileTypes: Record<string, number>;
  majorChanges: MajorChange[];
}

interface MajorChange {
  file: string;
  type: 'new_feature' | 'breaking_change' | 'refactor' | 'fix' | 'docs' | 'test';
  description: string;
  impact: 'low' | 'medium' | 'high';
}

interface TestingSummary {
  testsRun: number;
  testsPassed: number;
  testsFailed: number;
  testCoverage: number;
  testTypes: string[];
  ciStatus: 'passed' | 'failed' | 'pending' | 'running';
  testResults: TestResult[];
}

interface TestResult {
  suite: string;
  passed: number;
  failed: number;
  skipped: number;
  coverage: number;
  duration: number;
}

interface DescriptionMetadata {
  issueNumber: number;
  issueTitle: string;
  planId: string;
  estimatedEffort: number;
  actualEffort: number;
  complexity: string;
  riskLevel: string;
  dependencies: string[];
  breakingChanges: boolean;
  migrationRequired: boolean;
}

interface PRMetadata {
  autoGenerated: boolean;
  generationTime: Date;
  aiModel: string;
  tammaVersion: string;
  checksum: string;
  reviewRequired: boolean;
  approvalRequired: boolean;
  mergeStrategy: 'merge' | 'squash' | 'rebase';
}

interface PRCreationConfig {
  autoAssignReviewers: boolean;
  reviewerSelection: 'random' | 'round_robin' | 'code_ownership' | 'expertise_based';
  maxReviewers: number;
  requiredReviewers: string[];
  excludeReviewers: string[];
  autoLabels: boolean;
  labelMapping: Record<string, string[]>;
  draftMode: boolean;
  linkIssues: boolean;
  updateExisting: boolean;
  mergeOnApproval: boolean;
}

interface ReviewerInfo {
  username: string;
  expertise: string[];
  availability: 'available' | 'busy' | 'ooo';
  recentPRs: number;
  averageReviewTime: number;
  codeOwnership: Record<string, number>;
}
```

### Implementation Strategy

**1. PR Creation Engine**:

```typescript
class PullRequestCreator implements IPullRequestCreator {
  constructor(
    private gitPlatform: IGitPlatform,
    private aiProvider: IAIProvider,
    private reviewerManager: IReviewerManager,
    private config: PRCreationConfig,
    private logger: Logger,
    private eventStore: IEventStore
  ) {}

  async createPR(plan: DevelopmentPlan, result: ImplementationResult): Promise<PullRequest> {
    const startTime = Date.now();

    try {
      // Generate PR description
      const description = await this.generatePRDescription(plan, result);

      // Create PR on platform
      const pr = await this.createPROnPlatform(description, plan);

      // Assign reviewers if configured
      if (this.config.autoAssignReviewers) {
        await this.assignReviewers(pr, plan);
      }

      // Add labels if configured
      if (this.config.autoLabels) {
        await this.addLabels(pr, plan);
      }

      // Link issues if configured
      if (this.config.linkIssues) {
        await this.linkIssues(pr, plan);
      }

      // Validate PR creation
      const isValid = await this.validatePRCreation(pr);
      if (!isValid) {
        throw new PRCreationError('PR validation failed after creation');
      }

      // Add metadata
      pr.metadata = this.generatePRMetadata(plan, result);

      await this.eventStore.append({
        type: 'PR.CREATED.SUCCESS',
        tags: {
          issueId: plan.issueId,
          issueNumber: plan.issueNumber.toString(),
          planId: plan.id,
          prNumber: pr.number.toString(),
        },
        data: {
          prUrl: pr.url,
          title: pr.title,
          filesChanged: result.files.length,
          linesAdded: result.metrics.linesOfCode,
          testCoverage: result.metrics.testCoverage,
          reviewers: pr.reviewers.length,
          labels: pr.labels.length,
          creationTime: Date.now() - startTime,
        },
      });

      this.logger.info('Pull request created successfully', {
        issueNumber: plan.issueNumber,
        prNumber: pr.number,
        title: pr.title,
        url: pr.url,
        reviewers: pr.reviewers.length,
        labels: pr.labels.length,
      });

      return pr;
    } catch (error) {
      await this.eventStore.append({
        type: 'PR.CREATED.FAILED',
        tags: {
          issueId: plan.issueId,
          issueNumber: plan.issueNumber.toString(),
          planId: plan.id,
        },
        data: {
          error: error.message,
          creationTime: Date.now() - startTime,
        },
      });

      throw error;
    }
  }

  async generatePRDescription(
    plan: DevelopmentPlan,
    result: ImplementationResult
  ): Promise<PRDescription> {
    const prompt = this.buildPRDescriptionPrompt(plan, result);

    try {
      const response = await this.aiProvider.sendMessage({
        messages: [{ role: 'user', content: prompt }],
        maxTokens: 3000,
        temperature: 0.3,
        responseFormat: { type: 'json_object' },
      });

      const descriptionData = JSON.parse(response.content);

      return this.validateAndNormalizeDescription(descriptionData, plan, result);
    } catch (error) {
      this.logger.error('AI PR description generation failed, using fallback', { error });
      return this.generateFallbackDescription(plan, result);
    }
  }

  private buildPRDescriptionPrompt(plan: DevelopmentPlan, result: ImplementationResult): string {
    return `
Generate a comprehensive pull request description for the following implementation.

Issue Information:
- Number: ${plan.issueNumber}
- Title: ${plan.title}
- Labels: ${plan.issue.labels.join(', ')}

Development Plan:
- Summary: ${plan.summary}
- Approach: ${plan.approach.description}
- Estimated Effort: ${plan.estimatedEffort.totalMinutes} minutes
- Files to Change: ${plan.files.length}

Implementation Results:
- Files Generated: ${result.files.length}
- Lines of Code: ${result.metrics.linesOfCode}
- Test Coverage: ${result.metrics.testCoverage}%
- Cyclomatic Complexity: ${result.metrics.cyclomaticComplexity}
- Maintainability Index: ${result.metrics.maintainabilityIndex}

Files Changed:
${result.files
  .map(
    (file) => `
- ${file.path} (${file.type})
  - Functions: ${file.functions.length}
  - Classes: ${file.classes.length}
  - Dependencies: ${file.dependencies.join(', ')}
`
  )
  .join('')}

Test Results:
- Tests Run: ${result.metrics.testCoverage > 0 ? 'Available' : 'Not available'}
- Coverage: ${result.metrics.testCoverage}%
- Test Types: Unit, Integration

Requirements:
1. Generate a clear, descriptive PR title following project conventions
2. Write a comprehensive description that explains what was changed and why
3. Include technical details for reviewers
4. Highlight any breaking changes or migration requirements
5. Include testing information and coverage
6. Add relevant metadata and context
7. Follow markdown formatting best practices
8. Include sections for reviewers, testing, and deployment

Generate a JSON response with this structure:
{
  "title": "Clear, descriptive PR title",
  "body": "Full PR description in markdown format",
  "summary": "Brief summary of changes",
  "changes": {
    "filesAdded": 0,
    "filesModified": 0,
    "filesDeleted": 0,
    "linesAdded": 0,
    "linesDeleted": 0,
    "binaryFiles": 0,
    "fileTypes": {"ts": 5, "js": 2},
    "majorChanges": [
      {
        "file": "src/core/auth.ts",
        "type": "new_feature",
        "description": "Added JWT authentication system",
        "impact": "high"
      }
    ]
  },
  "testing": {
    "testsRun": 25,
    "testsPassed": 25,
    "testsFailed": 0,
    "testCoverage": 85,
    "testTypes": ["unit", "integration"],
    "ciStatus": "passed",
    "testResults": [
      {
        "suite": "auth.test.ts",
        "passed": 15,
        "failed": 0,
        "skipped": 0,
        "coverage": 90,
        "duration": 1500
      }
    ]
  },
  "metadata": {
    "issueNumber": ${plan.issueNumber},
    "issueTitle": "${plan.title}",
    "planId": "${plan.id}",
    "estimatedEffort": ${plan.estimatedEffort.totalMinutes},
    "actualEffort": ${result.metrics.linesOfCode * 2}, // Estimated
    "complexity": "${plan.estimatedEffort.confidence > 0.8 ? 'low' : plan.estimatedEffort.confidence > 0.5 ? 'medium' : 'high'}",
    "riskLevel": "medium",
    "dependencies": [],
    "breakingChanges": false,
    "migrationRequired": false
  }
}

The PR body should include these sections:
1. **Summary** - Brief overview of changes
2. **Changes** - Detailed description of what was changed
3. **Technical Details** - Implementation approach and technical decisions
4. **Testing** - Test coverage and test types
5. **Breaking Changes** - Any breaking changes (explicitly state if none)
6. **Migration** - Any migration requirements (explicitly state if none)
7. **Checklist** - Pre-merge checklist
8. **Screenshots/Diagrams** - If applicable (mention if none)

Focus on:
1. Clear communication of changes and their impact
2. Technical accuracy and completeness
3. Reviewer guidance and context
4. Testing and quality assurance information
5. Professional formatting and structure
6. Inclusion of all relevant metadata
7. Highlighting of important considerations
    `.trim();
  }

  private validateAndNormalizeDescription(
    descriptionData: any,
    plan: DevelopmentPlan,
    result: ImplementationResult
  ): PRDescription {
    if (!descriptionData.title || !descriptionData.body) {
      throw new Error('PR description must have title and body');
    }

    return {
      title: this.sanitizePRTitle(descriptionData.title, plan),
      body: this.formatPRBody(descriptionData.body, plan, result),
      summary: descriptionData.summary || this.generateSummary(plan, result),
      changes: this.validateChangeSummary(descriptionData.changes, result),
      testing: this.validateTestingSummary(descriptionData.testing, result),
      metadata: this.validateDescriptionMetadata(descriptionData.metadata, plan, result),
    };
  }

  private sanitizePRTitle(title: string, plan: DevelopmentPlan): string {
    // Apply project title conventions
    let sanitized = title.trim();

    // Add issue number if not present
    if (!sanitized.includes(`#${plan.issueNumber}`)) {
      sanitized = `#${plan.issueNumber} ${sanitized}`;
    }

    // Limit length (GitHub PR titles max 255 chars)
    if (sanitized.length > 250) {
      sanitized = sanitized.substring(0, 247) + '...';
    }

    return sanitized;
  }

  private formatPRBody(body: string, plan: DevelopmentPlan, result: ImplementationResult): string {
    // Ensure required sections are present
    const requiredSections = [
      '## Summary',
      '## Changes',
      '## Testing',
      '## Breaking Changes',
      '## Migration',
    ];

    let formattedBody = body;

    // Add missing sections
    for (const section of requiredSections) {
      if (!formattedBody.includes(section)) {
        formattedBody += `\n\n${section}\n\nTo be added...`;
      }
    }

    // Add metadata section
    formattedBody += this.generateMetadataSection(plan, result);

    // Add checklist
    formattedBody += this.generateChecklistSection(plan, result);

    return formattedBody;
  }

  private generateMetadataSection(plan: DevelopmentPlan, result: ImplementationResult): string {
    return `

---

### ü§ñ Auto-generated by Tamma

- **Issue**: #${plan.issueNumber} - ${plan.title}
- **Plan ID**: ${plan.id}
- **Estimated Effort**: ${plan.estimatedEffort.totalMinutes} minutes
- **Files Changed**: ${result.files.length}
- **Lines of Code**: ${result.metrics.linesOfCode}
- **Test Coverage**: ${result.metrics.testCoverage}%
- **Complexity**: ${plan.estimatedEffort.confidence > 0.8 ? 'Low' : plan.estimatedEffort.confidence > 0.5 ? 'Medium' : 'High'}
- **Generated**: ${new Date().toISOString()}
`;
  }

  private generateChecklistSection(plan: DevelopmentPlan, result: ImplementationResult): string {
    return `

### ‚úÖ Pre-merge Checklist

- [ ] Code follows project style guidelines
- [ ] All tests pass and coverage is acceptable
- [ ] Documentation is updated if required
- [ ] Breaking changes are documented (if any)
- [ ] Security considerations are addressed
- [ ] Performance impact is acceptable
- [ ] Code is reviewed and approved
- [ ] Merge conflicts are resolved
`;
  }

  private async createPROnPlatform(
    description: PRDescription,
    plan: DevelopmentPlan
  ): Promise<PullRequest> {
    try {
      const prRequest = {
        title: description.title,
        body: description.body,
        head: this.getBranchName(plan),
        base: this.config.baseBranch || 'main',
        draft: this.config.draftMode,
        maintainerCanModify: true,
      };

      const pr = await this.gitPlatform.createPullRequest(prRequest);

      return {
        id: pr.id,
        number: pr.number,
        title: pr.title,
        description: pr.body,
        url: pr.url,
        state: pr.state,
        author: pr.author,
        baseBranch: pr.baseBranch,
        headBranch: pr.headBranch,
        repository: pr.repository,
        createdAt: pr.createdAt,
        updatedAt: pr.updatedAt,
        mergeable: pr.mergeable,
        draft: pr.draft,
        reviewers: [],
        labels: [],
        linkedIssues: [],
        metadata: {} as PRMetadata,
      };
    } catch (error) {
      if (error.message.includes('already exists')) {
        // Update existing PR if configured
        if (this.config.updateExisting) {
          return await this.updateExistingPR(description, plan);
        }
      }

      throw new PRCreationError(`Failed to create PR: ${error.message}`, 'creation_failed', error);
    }
  }

  async assignReviewers(pr: PullRequest, plan: DevelopmentPlan): Promise<void> {
    try {
      const reviewers = await this.selectReviewers(plan, pr);

      if (reviewers.length === 0) {
        this.logger.info('No reviewers available for PR', {
          prNumber: pr.number,
          issueNumber: plan.issueNumber,
        });
        return;
      }

      await this.gitPlatform.assignReviewers(pr.number, reviewers);

      pr.reviewers = reviewers;

      this.logger.info('Reviewers assigned to PR', {
        prNumber: pr.number,
        reviewers: reviewers.join(', '),
      });
    } catch (error) {
      this.logger.warn('Failed to assign reviewers', {
        prNumber: pr.number,
        error: error.message,
      });

      // Don't fail the entire PR creation for reviewer assignment issues
    }
  }

  private async selectReviewers(plan: DevelopmentPlan, pr: PullRequest): Promise<string[]> {
    switch (this.config.reviewerSelection) {
      case 'random':
        return await this.reviewerManager.selectRandomReviewers(
          this.config.maxReviewers,
          this.config.excludeReviewers
        );

      case 'round_robin':
        return await this.reviewerManager.selectRoundRobinReviewers(
          this.config.maxReviewers,
          this.config.excludeReviewers
        );

      case 'code_ownership':
        return await this.reviewerManager.selectByCodeOwnership(
          plan.files.map((f) => f.path),
          this.config.maxReviewers,
          this.config.excludeReviewers
        );

      case 'expertise_based':
        return await this.reviewerManager.selectByExpertise(
          plan,
          this.config.maxReviewers,
          this.config.excludeReviewers
        );

      default:
        return [];
    }
  }

  async addLabels(pr: PullRequest, plan: DevelopmentPlan): Promise<void> {
    try {
      const labels = this.determineLabels(plan);

      if (labels.length === 0) {
        return;
      }

      await this.gitPlatform.addLabels(pr.number, labels);

      pr.labels = labels;

      this.logger.info('Labels added to PR', {
        prNumber: pr.number,
        labels: labels.join(', '),
      });
    } catch (error) {
      this.logger.warn('Failed to add labels', {
        prNumber: pr.number,
        error: error.message,
      });
    }
  }

  private determineLabels(plan: DevelopmentPlan): string[] {
    const labels: string[] = [];

    // Add labels based on configuration mapping
    for (const [pattern, patternLabels] of Object.entries(this.config.labelMapping)) {
      if (this.matchesPattern(plan, pattern)) {
        labels.push(...patternLabels);
      }
    }

    // Add labels based on plan characteristics
    if (plan.files.some((f) => f.action === 'create')) {
      labels.push('new-feature');
    }

    if (plan.files.some((f) => f.action === 'modify')) {
      labels.push('enhancement');
    }

    if (plan.files.some((f) => f.estimatedComplexity === 'high')) {
      labels.push('complex');
    }

    // Remove duplicates
    return [...new Set(labels)];
  }

  private matchesPattern(plan: DevelopmentPlan, pattern: string): boolean {
    // Simple pattern matching - can be enhanced
    const lowerPattern = pattern.toLowerCase();
    const lowerTitle = plan.title.toLowerCase();
    const lowerLabels = plan.issue.labels.map((l) => l.toLowerCase()).join(' ');

    return lowerTitle.includes(lowerPattern) || lowerLabels.includes(lowerPattern);
  }

  async linkIssues(pr: PullRequest, plan: DevelopmentPlan): Promise<void> {
    try {
      // Link the main issue
      await this.gitPlatform.linkIssueToPR(pr.number, plan.issueNumber);

      pr.linkedIssues = [plan.issueNumber.toString()];

      // Link related issues if mentioned in plan
      const relatedIssues = this.extractRelatedIssues(plan);
      for (const relatedIssue of relatedIssues) {
        await this.gitPlatform.linkIssueToPR(pr.number, relatedIssue);
        pr.linkedIssues.push(relatedIssue.toString());
      }

      this.logger.info('Issues linked to PR', {
        prNumber: pr.number,
        issues: pr.linkedIssues.join(', '),
      });
    } catch (error) {
      this.logger.warn('Failed to link issues', {
        prNumber: pr.number,
        error: error.message,
      });
    }
  }

  private extractRelatedIssues(plan: DevelopmentPlan): number[] {
    const issueRefs = plan.summary.match(/#(\d+)/g) || [];
    return issueRefs
      .map((ref) => parseInt(ref.substring(1)))
      .filter((num) => num !== plan.issueNumber && !isNaN(num));
  }

  async validatePRCreation(pr: PullRequest): Promise<boolean> {
    try {
      // Verify PR exists and is accessible
      const retrievedPR = await this.gitPlatform.getPullRequest(pr.number);

      if (!retrievedPR) {
        return false;
      }

      // Verify basic properties
      if (retrievedPR.title !== pr.title || retrievedPR.state !== 'open') {
        return false;
      }

      return true;
    } catch (error) {
      this.logger.error('PR validation failed', {
        prNumber: pr.number,
        error: error.message,
      });

      return false;
    }
  }

  private generatePRMetadata(plan: DevelopmentPlan, result: ImplementationResult): PRMetadata {
    return {
      autoGenerated: true,
      generationTime: new Date(),
      aiModel: this.aiProvider.getModelName(),
      tammaVersion: process.env.TAMMA_VERSION || 'unknown',
      checksum: this.generateChecksum(plan, result),
      reviewRequired: true,
      approvalRequired: this.config.requiredReviewers.length > 0,
      mergeStrategy: this.config.mergeStrategy || 'squash',
    };
  }

  private generateChecksum(plan: DevelopmentPlan, result: ImplementationResult): string {
    const content = JSON.stringify({
      planId: plan.id,
      files: result.files.map((f) => ({ path: f.path, content: f.content })),
      timestamp: Date.now(),
    });

    // Simple checksum - in production, use proper crypto
    return require('crypto').createHash('sha256').update(content).digest('hex').substring(0, 16);
  }

  private getBranchName(plan: DevelopmentPlan): string {
    // This should match the branch name created in Story 2.4
    return `feature/${plan.issueNumber}-${this.sanitizeTitle(plan.title)}`;
  }

  private sanitizeTitle(title: string): string {
    return title
      .toLowerCase()
      .replace(/[^a-z0-9\s-]/g, '')
      .replace(/\s+/g, '-')
      .substring(0, 50);
  }

  private generateFallbackDescription(
    plan: DevelopmentPlan,
    result: ImplementationResult
  ): PRDescription {
    return {
      title: `#${plan.issueNumber} ${plan.title}`,
      body: this.generateBasicPRBody(plan, result),
      summary: plan.summary,
      changes: {
        filesAdded: result.files.filter((f) => f.type === 'implementation').length,
        filesModified: 0,
        filesDeleted: 0,
        linesAdded: result.metrics.linesOfCode,
        linesDeleted: 0,
        binaryFiles: 0,
        fileTypes: this.getFileTypes(result.files),
        majorChanges: [],
      },
      testing: {
        testsRun: 0,
        testsPassed: 0,
        testsFailed: 0,
        testCoverage: result.metrics.testCoverage,
        testTypes: ['unit'],
        ciStatus: 'pending',
        testResults: [],
      },
      metadata: {
        issueNumber: plan.issueNumber,
        issueTitle: plan.title,
        planId: plan.id,
        estimatedEffort: plan.estimatedEffort.totalMinutes,
        actualEffort: result.metrics.linesOfCode * 2,
        complexity: 'medium',
        riskLevel: 'medium',
        dependencies: [],
        breakingChanges: false,
        migrationRequired: false,
      },
    };
  }

  private generateBasicPRBody(plan: DevelopmentPlan, result: ImplementationResult): string {
    return `## Summary

${plan.summary}

## Changes

This PR implements the requirements for issue #${plan.issueNumber}.

### Files Changed
${result.files.map((file) => `- \`${file.path}\``).join('\n')}

## Testing

- Test Coverage: ${result.metrics.testCoverage}%
- All tests should pass

## Breaking Changes

None

## Migration

No migration required.

---

### ü§ñ Auto-generated by Tamma

- **Issue**: #${plan.issueNumber} - ${plan.title}
- **Files Changed**: ${result.files.length}
- **Lines of Code**: ${result.metrics.linesOfCode}
- **Generated**: ${new Date().toISOString()}
`;
  }

  private getFileTypes(files: GeneratedFile[]): Record<string, number> {
    const types: Record<string, number> = {};

    for (const file of files) {
      const ext = file.path.split('.').pop()?.toLowerCase() || 'unknown';
      types[ext] = (types[ext] || 0) + 1;
    }

    return types;
  }
}
```

### Integration Points

**1. Git Platform Integration**:

- `createPullRequest()` - Create new PR
- `assignReviewers()` - Assign reviewers to PR
- `addLabels()` - Add labels to PR
- `linkIssueToPR()` - Link issues to PR
- `getPullRequest()` - Retrieve PR details

**2. AI Provider Integration**:

- PR description generation
- Change summarization
- Technical detail extraction

**3. Reviewer Management Integration**:

- Reviewer selection algorithms
- Expertise matching
- Code ownership analysis

**4. Event Store Integration**:

- `PR.CREATED.SUCCESS/FAILED`
- Complete audit trail for PR operations

### Testing Strategy

**Unit Tests**:

```typescript
describe('PullRequestCreator', () => {
  let prCreator: PullRequestCreator;
  let mockGitPlatform: jest.Mocked<IGitPlatform>;
  let mockAIProvider: jest.Mocked<IAIProvider>;
  let mockReviewerManager: jest.Mocked<IReviewerManager>;

  beforeEach(() => {
    mockGitPlatform = createMockGitPlatform();
    mockAIProvider = createMockAIProvider();
    mockReviewerManager = createMockReviewerManager();
    prCreator = new PullRequestCreator(
      mockGitPlatform,
      mockAIProvider,
      mockReviewerManager,
      createMockPRConfig(),
      mockLogger,
      mockEventStore
    );
  });

  describe('createPR', () => {
    it('should create PR with comprehensive description', async () => {
      const plan = createMockDevelopmentPlan();
      const result = createMockImplementationResult();

      mockAIProvider.sendMessage.mockResolvedValue({
        content: JSON.stringify(createMockPRDescription()),
        usage: { tokens: 2000 },
      });

      mockGitPlatform.createPullRequest.mockResolvedValue({
        id: 'pr-123',
        number: 123,
        title: '#123 Add authentication feature',
        body: 'PR description',
        url: 'https://github.com/test/repo/pull/123',
        state: 'open',
        author: 'tamma-bot',
        baseBranch: 'main',
        headBranch: 'feature/123-add-auth',
        repository: { name: 'test-repo', owner: 'test' },
        createdAt: new Date(),
        updatedAt: new Date(),
      });

      mockReviewerManager.selectRandomReviewers.mockResolvedValue(['reviewer1', 'reviewer2']);
      mockGitPlatform.assignReviewers.mockResolvedValue();
      mockGitPlatform.addLabels.mockResolvedValue();
      mockGitPlatform.linkIssueToPR.mockResolvedValue();

      const pr = await prCreator.createPR(plan, result);

      expect(pr.number).toBe(123);
      expect(pr.title).toContain('#123');
      expect(pr.reviewers).toHaveLength(2);
      expect(mockGitPlatform.createPullRequest).toHaveBeenCalled();
      expect(mockGitPlatform.assignReviewers).toHaveBeenCalledWith(123, ['reviewer1', 'reviewer2']);
    });

    it('should handle AI description generation failure', async () => {
      const plan = createMockDevelopmentPlan();
      const result = createMockImplementationResult();

      mockAIProvider.sendMessage.mockRejectedValue(new Error('AI unavailable'));

      mockGitPlatform.createPullRequest.mockResolvedValue({
        id: 'pr-456',
        number: 456,
        title: '#456 Test issue',
        body: 'Basic PR description',
        url: 'https://github.com/test/repo/pull/456',
        state: 'open',
        author: 'tamma-bot',
        baseBranch: 'main',
        headBranch: 'feature/456-test-issue',
        repository: { name: 'test-repo', owner: 'test' },
        createdAt: new Date(),
        updatedAt: new Date(),
      });

      const pr = await prCreator.createPR(plan, result);

      expect(pr.title).toBe('#456 Test issue');
      expect(pr.body).toContain('Auto-generated by Tamma');
    });

    it('should handle reviewer assignment failure gracefully', async () => {
      const plan = createMockDevelopmentPlan();
      const result = createMockImplementationResult();

      mockAIProvider.sendMessage.mockResolvedValue({
        content: JSON.stringify(createMockPRDescription()),
        usage: { tokens: 2000 },
      });

      mockGitPlatform.createPullRequest.mockResolvedValue(createMockPR());
      mockReviewerManager.selectRandomReviewers.mockResolvedValue(['reviewer1']);
      mockGitPlatform.assignReviewers.mockRejectedValue(new Error('Permission denied'));

      const pr = await prCreator.createPR(plan, result);

      expect(pr.reviewers).toHaveLength(0); // Should not fail PR creation
      expect(mockGitPlatform.createPullRequest).toHaveBeenCalled();
    });
  });

  describe('generatePRDescription', () => {
    it('should generate comprehensive PR description', async () => {
      const plan = createMockDevelopmentPlan();
      const result = createMockImplementationResult();

      mockAIProvider.sendMessage.mockResolvedValue({
        content: JSON.stringify(createMockPRDescription()),
        usage: { tokens: 2000 },
      });

      const description = await prCreator.generatePRDescription(plan, result);

      expect(description.title).toContain('#123');
      expect(description.body).toContain('## Summary');
      expect(description.body).toContain('## Changes');
      expect(description.body).toContain('## Testing');
      expect(description.changes.filesAdded).toBeGreaterThan(0);
      expect(description.testing.testCoverage).toBeGreaterThan(0);
    });
  });
});
```

### Configuration Examples

**PR Creation Configuration**:

```yaml
pr_creation:
  auto_assign_reviewers: true
  reviewer_selection: 'code_ownership' # random, round_robin, code_ownership, expertise_based
  max_reviewers: 3
  required_reviewers: []
  exclude_reviewers: ['bot', 'external-contractor']

  auto_labels: true
  label_mapping:
    'security': ['security-review']
    'breaking': ['breaking-change', 'major']
    'documentation': ['docs']
    'performance': ['performance']
    'bug': ['bugfix']
    'feature': ['enhancement', 'new-feature']

  draft_mode: false
  link_issues: true
  update_existing: true
  merge_on_approval: false
  base_branch: 'main'
  merge_strategy: 'squash' # merge, squash, rebase

  description:
    include_metadata: true
    include_checklist: true
    include_testing_summary: true
    include_breaking_changes: true
    include_migration_notes: true
    max_title_length: 250

  validation:
    check_pr_exists: true
    verify_reviewers: true
    verify_labels: true
    verify_issue_links: true
```

---

## Implementation Notes

**Key Considerations**:

1. **PR Quality**: Generated PRs should be as comprehensive as human-created ones.

2. **Reviewer Selection**: Intelligent reviewer assignment improves code review quality.

3. **Automation Balance**: Balance automation with human oversight and control.

4. **Error Handling**: PR creation failures should not block the entire workflow.

5. **Metadata Tracking**: Include comprehensive metadata for traceability and analysis.

6. **Platform Differences**: Handle variations between different Git platforms.

**Performance Targets**:

- PR description generation: < 30 seconds
- PR creation: < 10 seconds
- Reviewer assignment: < 5 seconds
- Label assignment: < 3 seconds
- Total PR creation: < 60 seconds

**Security Considerations**:

- Validate PR content for sensitive information
- Handle reviewer permissions appropriately
- Ensure proper access controls for PR operations
- Sanitize PR descriptions and metadata
- Handle confidential issue information properly

**PR Best Practices**:

- Clear, descriptive titles with issue numbers
- Comprehensive descriptions with technical details
- Proper labeling for categorization and filtering
- Appropriate reviewer assignment based on expertise
- Linking to related issues and documentation
- Including testing information and coverage
- Highlighting breaking changes and migration requirements
- Providing clear review guidelines and checklists

### References

- **üî¥ MANDATORY PROCESS:** [BEFORE_YOU_CODE.md](../../BEFORE_YOU_CODE.md)
- **Knowledge Base:** [.dev/README.md](../../.dev/README.md) - Search spikes, bugs, findings, decisions
