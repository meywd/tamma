# Story 1.5-5: Docker Packaging

**Epic:** 1.5 - Deployment, Packaging & Operations  
**Status:** Ready for Development  
**Priority:** MVP Critical  
**Estimated Effort:** 3 days

## Overview

Create multi-stage Dockerfile for optimized image size, docker-compose configuration for local development, and container publishing workflow. Docker packaging enables reproducible deployments across environments and provides foundation for Kubernetes deployment (Story 1.5-10).

## Technical Context

### ⚠️ Development Process Reminder

**Before implementing this story, ensure you have:**
1. ✅ Read [BEFORE_YOU_CODE.md](../../BEFORE_YOU_CODE.md)
2. ✅ Searched `.dev/` directory for related spikes, bugs, findings, and decisions
3. ✅ Reviewed relevant documentation in `docs/` directory
4. ✅ Checked existing code patterns for similar functionality
5. ✅ Planned TDD approach (Red-Green-Refactor cycle)


Docker packaging is essential for Tamma's deployment strategy. The multi-stage Dockerfile will create optimized production images under 500MB using Node.js 22 Alpine base, with proper security practices (non-root user, minimal attack surface). The docker-compose configuration will provide complete local development environment including Tamma orchestrator, PostgreSQL, and Redis.

The implementation must support both service mode and web server mode, include health checks for container orchestration, enable environment variable configuration, and provide automated image publishing to multiple registries.

## Acceptance Criteria

1. Multi-stage Dockerfile builds optimized image (<500MB)
2. Non-root user (uid 1001) for security
3. Health check configured in Dockerfile
4. docker-compose.yml for local development (orchestrator + postgres + redis)
5. Image published to Docker Hub and GitHub Container Registry
6. Environment variable configuration (no config file required)
7. Container starts in <10 seconds and responds to health checks
8. Integration tests validate Docker container startup and basic functionality
9. Security scan passes (no critical vulnerabilities)

## Implementation Details

### Dockerfile

```dockerfile
# Multi-stage Dockerfile for Tamma
# Stage 1: Build stage
FROM node:22-alpine AS builder

# Set working directory
WORKDIR /app

# Install build dependencies
RUN apk add --no-cache \
    python3 \
    make \
    g++ \
    git

# Enable corepack and install pnpm
RUN corepack enable && corepack prepare pnpm@latest --activate

# Copy package files
COPY package.json pnpm-lock.yaml pnpm-workspace.yaml ./
COPY packages/core/package.json ./packages/core/
COPY packages/cli/package.json ./packages/cli/
COPY packages/server/package.json ./packages/server/
COPY packages/config/package.json ./packages/config/
COPY packages/providers/package.json ./packages/providers/
COPY packages/platforms/package.json ./packages/platforms/
COPY packages/shared/package.json ./packages/shared/
COPY packages/observability/package.json ./packages/observability/

# Install dependencies
RUN pnpm install --frozen-lockfile

# Copy source code
COPY packages/ ./packages/
COPY tsconfig.json ./
COPY .npmrc ./

# Build all packages
RUN pnpm run build

# Generate production dependencies list
RUN pnpm list --prod --json > /tmp/deps.json

# Stage 2: Production stage
FROM node:22-alpine AS production

# Install runtime dependencies
RUN apk add --no-cache \
    dumb-init \
    curl \
    ca-certificates \
    && rm -rf /var/cache/apk/*

# Create app user
RUN addgroup -g 1001 -S tamma && \
    adduser -u 1001 -S tamma -G tamma

# Set working directory
WORKDIR /app

# Enable corepack and install pnpm
RUN corepack enable && corepack prepare pnpm@latest --activate

# Copy package files
COPY package.json pnpm-lock.yaml pnpm-workspace.yaml ./
COPY packages/core/package.json ./packages/core/
COPY packages/server/package.json ./packages/server/
COPY packages/config/package.json ./packages/config/
COPY packages/shared/package.json ./packages/shared/
COPY packages/observability/package.json ./packages/observability/

# Install only production dependencies
RUN pnpm install --frozen-lockfile --prod

# Copy built packages
COPY --from=builder /app/packages/core/dist ./packages/core/dist
COPY --from=builder /app/packages/server/dist ./packages/server/dist
COPY --from=builder /app/packages/config/dist ./packages/config/dist
COPY --from=builder /app/packages/shared/dist ./packages/shared/dist
COPY --from=builder /app/packages/observability/dist ./packages/observability/dist

# Copy package.json files for built packages
COPY --from=builder /app/packages/core/package.json ./packages/core/
COPY --from=builder /app/packages/server/package.json ./packages/server/
COPY --from=builder /app/packages/config/package.json ./packages/config/
COPY --from=builder /app/packages/shared/package.json ./packages/shared/
COPY --from=builder /app/packages/observability/package.json ./packages/observability/

# Change ownership to tamma user
RUN chown -R tamma:tamma /app

# Switch to non-root user
USER tamma

# Environment variables
ENV NODE_ENV=production
ENV TAMMA_MODE=service
ENV PATH="/app/node_modules/.bin:${PATH}"

# Expose ports
EXPOSE 3000 8080 9090

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:3000/health || exit 1

# Default command (service mode)
ENTRYPOINT ["dumb-init", "--"]
CMD ["node", "packages/server/dist/service.js"]

# Labels for metadata
LABEL org.opencontainers.image.title="Tamma"
LABEL org.opencontainers.image.description="AI-powered autonomous development orchestration"
LABEL org.opencontainers.image.source="https://github.com/meywd/tamma"
LABEL org.opencontainers.image.licenses="MIT"
LABEL org.opencontainers.image.version="1.0.0"
```

### Docker Compose for Development

```yaml
# docker-compose.yml
version: '3.8'

services:
  # Tamma Orchestrator (Service Mode)
  tamma-orchestrator:
    build:
      context: .
      dockerfile: Dockerfile
      target: production
    image: tamma:latest
    container_name: tamma-orchestrator
    restart: unless-stopped
    environment:
      # Core configuration
      - NODE_ENV=production
      - TAMMA_MODE=service
      - TAMMA_LOG_LEVEL=info

      # AI Provider configuration
      - TAMMA_AI_PROVIDER=anthropic-claude
      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}

      # Git Platform configuration
      - TAMMA_GIT_PLATFORM=github
      - GITHUB_TOKEN=${GITHUB_TOKEN}

      # Database configuration
      - DATABASE_URL=postgresql://tamma:${POSTGRES_PASSWORD}@postgres:5432/tamma

      # Queue configuration
      - TAMMA_QUEUE_TYPE=redis
      - REDIS_URL=redis://redis:6379

      # Service configuration
      - TAMMA_SERVICE_POLL_INTERVAL=5000
      - TAMMA_SERVICE_MAX_CONCURRENT_TASKS=3
      - TAMMA_SERVICE_MAX_RETRIES=3

      # Web server configuration (if enabled)
      - TAMMA_WEB_HOST=0.0.0.0
      - TAMMA_WEB_PORT=3000
      - TAMMA_WEB_JWT_SECRET=${JWT_SECRET}

      # Webhook configuration
      - GITHUB_WEBHOOK_SECRET=${GITHUB_WEBHOOK_SECRET}
      - GITLAB_WEBHOOK_TOKEN=${GITLAB_WEBHOOK_TOKEN}
      - TAMMA_WEBHOOK_BOT_USERNAME=tamma-bot

      # Health check configuration
      - TAMMA_HEALTH_CHECK_ENABLED=true
      - TAMMA_HEALTH_CHECK_PORT=8080

      # Metrics configuration
      - TAMMA_METRICS_ENABLED=true
      - TAMMA_METRICS_PORT=9090
    ports:
      - '3000:3000' # Web server API
      - '8080:8080' # Health checks
      - '9090:9090' # Metrics
    volumes:
      # Mount configuration directory (read-only)
      - ./config:/app/config:ro
      # Mount logs directory
      - ./logs:/app/logs
      # Mount workspace directory for git operations
      - ./workspace:/app/workspace
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    networks:
      - tamma-network
    healthcheck:
      test: ['CMD', 'curl', '-f', 'http://localhost:8080/health']
      interval: 30s
      timeout: 3s
      retries: 3
      start_period: 10s

  # PostgreSQL Database
  postgres:
    image: postgres:16-alpine
    container_name: tamma-postgres
    restart: unless-stopped
    environment:
      - POSTGRES_DB=tamma
      - POSTGRES_USER=tamma
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_INITDB_ARGS=--encoding=UTF-8 --lc-collate=C --lc-ctype=C
    ports:
      - '5432:5432'
    volumes:
      # Data persistence
      - postgres-data:/var/lib/postgresql/data
      # Initialization scripts
      - ./database/init:/docker-entrypoint-initdb.d:ro
      # Configuration
      - ./database/postgresql.conf:/etc/postgresql/postgresql.conf:ro
    networks:
      - tamma-network
    healthcheck:
      test: ['CMD-SHELL', 'pg_isready -U tamma -d tamma']
      interval: 5s
      timeout: 3s
      retries: 5
      start_period: 5s
    command: postgres -c config_file=/etc/postgresql/postgresql.conf

  # Redis Cache and Queue
  redis:
    image: redis:7-alpine
    container_name: tamma-redis
    restart: unless-stopped
    environment:
      - REDIS_PASSWORD=${REDIS_PASSWORD}
    ports:
      - '6379:6379'
    volumes:
      # Data persistence
      - redis-data:/data
      # Configuration
      - ./redis/redis.conf:/usr/local/etc/redis/redis.conf:ro
    networks:
      - tamma-network
    healthcheck:
      test: ['CMD', 'redis-cli', '--raw', 'incr', 'ping']
      interval: 5s
      timeout: 3s
      retries: 5
      start_period: 5s
    command: redis-server /usr/local/etc/redis/redis.conf

  # Nginx Reverse Proxy (Optional)
  nginx:
    image: nginx:alpine
    container_name: tamma-nginx
    restart: unless-stopped
    ports:
      - '80:80'
      - '443:443'
    volumes:
      # Nginx configuration
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      # SSL certificates (if using HTTPS)
      - ./nginx/ssl:/etc/nginx/ssl:ro
      # Static files (if serving web UI)
      - ./web/dist:/usr/share/nginx/html:ro
    depends_on:
      - tamma-orchestrator
    networks:
      - tamma-network
    healthcheck:
      test: ['CMD', 'wget', '--quiet', '--tries=1', '--spider', 'http://localhost/health']
      interval: 30s
      timeout: 3s
      retries: 3

  # Prometheus Monitoring (Optional)
  prometheus:
    image: prom/prometheus:latest
    container_name: tamma-prometheus
    restart: unless-stopped
    ports:
      - '9091:9090'
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml:ro
      - prometheus-data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/etc/prometheus/console_libraries'
      - '--web.console.templates=/etc/prometheus/consoles'
      - '--storage.tsdb.retention.time=200h'
      - '--web.enable-lifecycle'
    networks:
      - tamma-network
    profiles:
      - monitoring

  # Grafana Dashboard (Optional)
  grafana:
    image: grafana/grafana:latest
    container_name: tamma-grafana
    restart: unless-stopped
    ports:
      - '3001:3000'
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_PASSWORD}
      - GF_USERS_ALLOW_SIGN_UP=false
    volumes:
      - grafana-data:/var/lib/grafana
      - ./monitoring/grafana/dashboards:/etc/grafana/provisioning/dashboards:ro
      - ./monitoring/grafana/datasources:/etc/grafana/provisioning/datasources:ro
    depends_on:
      - prometheus
    networks:
      - tamma-network
    profiles:
      - monitoring

# Networks
networks:
  tamma-network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16

# Volumes
volumes:
  postgres-data:
    driver: local
  redis-data:
    driver: local
  prometheus-data:
    driver: local
  grafana-data:
    driver: local
```

### Docker Compose for Testing

```yaml
# docker-compose.test.yml
version: '3.8'

services:
  # Tamma Test Container
  tamma-test:
    build:
      context: .
      dockerfile: Dockerfile
      target: production
    image: tamma:test
    container_name: tamma-test
    environment:
      - NODE_ENV=test
      - TAMMA_MODE=service
      - TAMMA_LOG_LEVEL=debug
      - TAMMA_AI_PROVIDER=anthropic-claude
      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY_TEST}
      - TAMMA_GIT_PLATFORM=github
      - GITHUB_TOKEN=${GITHUB_TOKEN_TEST}
      - DATABASE_URL=postgresql://tamma:testpassword@postgres-test:5432/tamma_test
      - TAMMA_QUEUE_TYPE=memory
      - TAMMA_SERVICE_POLL_INTERVAL=1000
      - TAMMA_SERVICE_MAX_CONCURRENT_TASKS=1
      - TAMMA_WEB_HOST=0.0.0.0
      - TAMMA_WEB_PORT=3000
      - TAMMA_WEB_JWT_SECRET=test-jwt-secret
    ports:
      - '3000:3000'
      - '8080:8080'
    depends_on:
      postgres-test:
        condition: service_healthy
    networks:
      - tamma-test-network
    command: ['node', 'packages/server/dist/service.js']

  # PostgreSQL Test Database
  postgres-test:
    image: postgres:16-alpine
    container_name: tamma-postgres-test
    environment:
      - POSTGRES_DB=tamma_test
      - POSTGRES_USER=tamma
      - POSTGRES_PASSWORD=testpassword
    ports:
      - '5433:5432'
    networks:
      - tamma-test-network
    healthcheck:
      test: ['CMD-SHELL', 'pg_isready -U tamma -d tamma_test']
      interval: 2s
      timeout: 2s
      retries: 10
      start_period: 2s

networks:
  tamma-test-network:
    driver: bridge
```

### Environment Configuration Files

```bash
# .env.example
# Copy this file to .env and fill in your values

# AI Provider Configuration
ANTHROPIC_API_KEY=sk-ant-api03-...
OPENAI_API_KEY=sk-...
GITHUB_TOKEN=ghp_...

# Database Configuration
POSTGRES_PASSWORD=your_secure_password_here
DATABASE_URL=postgresql://tamma:your_secure_password_here@postgres:5432/tamma

# Redis Configuration
REDIS_PASSWORD=your_redis_password_here
REDIS_URL=redis://:your_redis_password_here@redis:6379

# Webhook Configuration
GITHUB_WEBHOOK_SECRET=your_github_webhook_secret_here
GITLAB_WEBHOOK_TOKEN=your_gitlab_webhook_token_here
JWT_SECRET=your_jwt_secret_at_least_32_characters_long

# Monitoring Configuration
GRAFANA_PASSWORD=your_grafana_password_here

# Tamma Configuration
TAMMA_WEBHOOK_BOT_USERNAME=tamma-bot
TAMMA_LOG_LEVEL=info
TAMMA_SERVICE_POLL_INTERVAL=5000
TAMMA_SERVICE_MAX_CONCURRENT_TASKS=3
```

### Build and Publish Scripts

```bash
#!/bin/bash
# scripts/build-docker.sh

set -e

# Configuration
IMAGE_NAME="tamma"
VERSION=${1:-latest}
REGISTRY=${2:-"docker.io/meywd"}

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo -e "${GREEN}Building Tamma Docker image...${NC}"

# Build the image
docker build \
  --target production \
  --tag "${REGISTRY}/${IMAGE_NAME}:${VERSION}" \
  --tag "${REGISTRY}/${IMAGE_NAME}:latest" \
  .

echo -e "${GREEN}Image built successfully!${NC}"

# Show image size
echo -e "${YELLOW}Image information:${NC}"
docker images "${REGISTRY}/${IMAGE_NAME}:${VERSION}"

# Run security scan (if trivy is available)
if command -v trivy &> /dev/null; then
    echo -e "${GREEN}Running security scan...${NC}"
    trivy image "${REGISTRY}/${IMAGE_NAME}:${VERSION}"
else
    echo -e "${YELLOW}Trivy not found. Skipping security scan.${NC}"
fi

echo -e "${GREEN}Build completed successfully!${NC}"
```

```bash
#!/bin/bash
# scripts/publish-docker.sh

set -e

# Configuration
IMAGE_NAME="tamma"
VERSION=${1:-latest}
REGISTRIES=("docker.io/meywd" "ghcr.io/meywd")

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Build image first
./scripts/build-docker.sh "$VERSION"

echo -e "${GREEN}Publishing Tamma Docker image to registries...${NC}"

# Publish to all registries
for REGISTRY in "${REGISTRIES[@]}"; do
    echo -e "${YELLOW}Publishing to ${REGISTRY}...${NC}"

    # Tag for this registry
    docker tag "${IMAGE_NAME}:${VERSION}" "${REGISTRY}/${IMAGE_NAME}:${VERSION}"
    docker tag "${IMAGE_NAME}:latest" "${REGISTRY}/${IMAGE_NAME}:latest"

    # Push version tag
    docker push "${REGISTRY}/${IMAGE_NAME}:${VERSION}"

    # Push latest tag
    docker push "${REGISTRY}/${IMAGE_NAME}:latest"

    echo -e "${GREEN}Published to ${REGISTRY}${NC}"
done

echo -e "${GREEN}All images published successfully!${NC}"
```

### GitHub Actions Workflow

```yaml
# .github/workflows/docker.yml
name: Build and Publish Docker Images

on:
  push:
    branches: [main, develop]
    tags: ['v*']
  pull_request:
    branches: [main]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}}
            type=sha

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          target: production
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64

      - name: Run security scan
        if: github.event_name != 'pull_request'
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.version }}
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results to GitHub Security tab
        if: github.event_name != 'pull_request'
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'
```

### Dockerignore

```dockerignore
# Node modules
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Build artifacts
dist/
build/
*.tsbuildinfo

# Environment files
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# IDE files
.vscode/
.idea/
*.swp
*.swo
*~

# OS files
.DS_Store
Thumbs.db

# Git
.git/
.gitignore

# Documentation
docs/
*.md

# Test files
coverage/
.nyc_output/
test-results/

# Logs
logs/
*.log

# Runtime data
pids/
*.pid
*.seed
*.pid.lock

# Temporary files
tmp/
temp/

# Development files
.dev/
.spikes/

# CI/CD
.github/
.gitlab-ci.yml

# Docker files (except the main one)
docker-compose*.yml
docker-compose*.yaml
Dockerfile.*
!Dockerfile

# Scripts
scripts/

# Configuration examples
*.example
.env.example

# Database
database/

# Monitoring
monitoring/

# Nginx
nginx/

# Redis
redis/

# Workspace
workspace/
```

## Testing Strategy

### Container Integration Tests

```typescript
// tests/integration/docker.test.ts
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { DockerComposeEnvironment } from 'testcontainers';
import { execSync } from 'child_process';
import fetch from 'node-fetch';

describe('Docker Container Integration Tests', () => {
  let environment: DockerComposeEnvironment;
  let containerUrl: string;

  beforeAll(async () => {
    // Start test environment
    environment = await new DockerComposeEnvironment('.', ['docker-compose.test.yml']).up();

    // Get container URL
    const container = environment.getContainer('tamma-test');
    const port = container.getMappedPort(3000);
    containerUrl = `http://localhost:${port}`;

    // Wait for container to be ready
    await waitForHealth(containerUrl);
  }, 60000);

  afterAll(async () => {
    if (environment) {
      await environment.down();
    }
  });

  it('should start container successfully', async () => {
    const response = await fetch(`${containerUrl}/health`);
    expect(response.status).toBe(200);

    const data = await response.json();
    expect(data.status).toBe('ok');
  });

  it('should respond to readiness probe', async () => {
    const response = await fetch(`${containerUrl}/ready`);
    expect(response.status).toBe(200);

    const data = await response.json();
    expect(data.status).toBe('ready');
  });

  it('should have correct environment variables', async () => {
    const container = environment.getContainer('tamma-test');
    const env = await container.exec(['printenv']).output();

    expect(env).toContain('NODE_ENV=test');
    expect(env).toContain('TAMMA_MODE=service');
    expect(env).toContain('TAMMA_LOG_LEVEL=debug');
  });

  it('should run as non-root user', async () => {
    const container = environment.getContainer('tamma-test');
    const whoami = await container.exec(['whoami']).output();
    expect(whoami.trim()).toBe('tamma');
  });

  it('should have correct user ID', async () => {
    const container = environment.getContainer('tamma-test');
    const id = await container.exec(['id', '-u']).output();
    expect(id.trim()).toBe('1001');
  });

  it('should have reasonable image size', async () => {
    // Build image and check size
    execSync('docker build -t tamma:test-size .', { stdio: 'inherit' });
    const inspect = execSync('docker inspect tamma:test-size --format="{{.Size}}"', {
      encoding: 'utf8',
    });
    const sizeBytes = parseInt(inspect.trim());
    const sizeMB = sizeBytes / (1024 * 1024);

    expect(sizeMB).toBeLessThan(500); // Should be under 500MB
  });
});

async function waitForHealth(url: string, timeout = 30000): Promise<void> {
  const start = Date.now();

  while (Date.now() - start < timeout) {
    try {
      const response = await fetch(url);
      if (response.ok) {
        return;
      }
    } catch (error) {
      // Container not ready yet
    }

    await new Promise((resolve) => setTimeout(resolve, 1000));
  }

  throw new Error(`Container not healthy after ${timeout}ms`);
}
```

### Security Scan Tests

```bash
#!/bin/bash
# scripts/security-scan.sh

set -e

IMAGE_NAME=${1:-"tamma:latest"}

echo "Running security scan on $IMAGE_NAME"

# Check if trivy is installed
if ! command -v trivy &> /dev/null; then
    echo "Installing Trivy..."
    sudo apt-get update
    sudo apt-get install wget apt-transport-https gnupg lsb-release
    wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
    echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
    sudo apt-get update
    sudo apt-get install trivy
fi

# Run security scan
echo "Scanning for vulnerabilities..."
trivy image --exit-code 1 --severity HIGH,CRITICAL "$IMAGE_NAME"

echo "Security scan completed successfully!"
```

## Configuration

### Environment Variables for Container

```typescript
// @tamma/config/src/schemas/docker.schema.ts
export const DockerConfigSchema = z.object({
  // Container mode
  NODE_ENV: z.enum(['development', 'production', 'test']).default('production'),
  TAMMA_MODE: z.enum(['cli', 'service', 'web', 'worker']).default('service'),

  // Logging
  TAMMA_LOG_LEVEL: z.enum(['error', 'warn', 'info', 'debug']).default('info'),

  // AI Provider
  TAMMA_AI_PROVIDER: z.string().default('anthropic-claude'),
  ANTHROPIC_API_KEY: z.string().optional(),
  OPENAI_API_KEY: z.string().optional(),

  // Git Platform
  TAMMA_GIT_PLATFORM: z.string().default('github'),
  GITHUB_TOKEN: z.string().optional(),
  GITLAB_TOKEN: z.string().optional(),

  // Database
  DATABASE_URL: z.string().url().optional(),

  // Queue
  TAMMA_QUEUE_TYPE: z.enum(['memory', 'redis', 'sqs']).default('memory'),
  REDIS_URL: z.string().url().optional(),

  // Service configuration
  TAMMA_SERVICE_POLL_INTERVAL: z.coerce.number().min(100).max(60000).default(5000),
  TAMMA_SERVICE_MAX_CONCURRENT_TASKS: z.coerce.number().min(1).max(20).default(3),
  TAMMA_SERVICE_MAX_RETRIES: z.coerce.number().min(0).max(10).default(3),

  // Web server
  TAMMA_WEB_HOST: z.string().default('0.0.0.0'),
  TAMMA_WEB_PORT: z.coerce.number().min(1).max(65535).default(3000),
  TAMMA_WEB_JWT_SECRET: z.string().min(32),

  // Webhooks
  GITHUB_WEBHOOK_SECRET: z.string().optional(),
  GITLAB_WEBHOOK_TOKEN: z.string().optional(),
  TAMMA_WEBHOOK_BOT_USERNAME: z.string().default('tamma-bot'),

  // Health checks
  TAMMA_HEALTH_CHECK_ENABLED: z.coerce.boolean().default(true),
  TAMMA_HEALTH_CHECK_PORT: z.coerce.number().min(1).max(65535).default(8080),

  // Metrics
  TAMMA_METRICS_ENABLED: z.coerce.boolean().default(true),
  TAMMA_METRICS_PORT: z.coerce.number().min(1).max(65535).default(9090),
});

export type DockerConfig = z.infer<typeof DockerConfigSchema>;
```

## Performance Considerations

1. **Image Size**: Multi-stage build to minimize final image size
2. **Layer Caching**: Optimize Dockerfile layer ordering for better caching
3. **Startup Time**: Use Alpine Linux and minimal dependencies
4. **Memory Usage**: Efficient Node.js configuration and garbage collection
5. **Network Performance**: Optimize for container networking

## Security Considerations

1. **Non-root User**: Run container as non-root user (uid 1001)
2. **Minimal Base Image**: Use Alpine Linux to reduce attack surface
3. **Security Scanning**: Automated vulnerability scanning with Trivy
4. **Secrets Management**: Use environment variables, never embed secrets
5. **Network Isolation**: Proper network segmentation in docker-compose

## Monitoring and Observability

1. **Health Checks**: Comprehensive health check endpoints
2. **Metrics Export**: Prometheus metrics for monitoring
3. **Structured Logging**: JSON logs for log aggregation
4. **Resource Monitoring**: CPU, memory, and disk usage tracking
5. **Security Monitoring**: Vulnerability scanning and security alerts

## Dependencies

### Build Dependencies

- `docker` - Container runtime
- `docker-compose` - Multi-container orchestration
- `node:22-alpine` - Base image
- `trivy` - Security scanning (optional)

### Runtime Dependencies

- `dumb-init` - Proper signal handling
- `curl` - Health check utility
- `ca-certificates` - SSL certificate bundle

## Success Metrics

1. **Image Size**: <500MB for production image
2. **Startup Time**: <10 seconds to health check
3. **Security**: Zero critical vulnerabilities
4. **Performance**: <100ms health check response time
5. **Reliability**: >99.9% container uptime

---

## ⚠️ MANDATORY: Before You Code

**ALL contributors MUST read and follow the comprehensive development process:**

📖 **[BEFORE_YOU_CODE.md](../../BEFORE_YOU_CODE.md)**

This mandatory guide includes:
- 7-Phase Development Workflow (Read → Research → Break Down → TDD → Quality Gates → Failure Handling)
- Knowledge Base Usage (.dev/ directory: spikes, bugs, findings, decisions)
- TRACE/DEBUG Logging Requirements for all functions
- Test-Driven Development (TDD) mandatory workflow
- 100% Test Coverage requirement
- Build Success enforcement
- Automatic retry and developer alert procedures

**Failure to follow this process will result in rework.**

---

**Technical Context Created:** 2025-10-29  
**Last Updated:** 2025-10-29  
**Next Story:** 1.5-6 - Webhook Integration

### References

- **🔴 MANDATORY PROCESS:** [BEFORE_YOU_CODE.md](../../BEFORE_YOU_CODE.md)
- **Knowledge Base:** [.dev/README.md](../../.dev/README.md) - Search spikes, bugs, findings, decisions
