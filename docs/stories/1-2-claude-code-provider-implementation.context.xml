<story-context id="bmad/bmm/workflows/4-implementation/story-context" v="1.0">
  <metadata>
    <epicId>1</epicId>
    <storyId>2</storyId>
    <title>Claude Code Provider Implementation</title>
    <status>ready-for-dev</status>
    <generatedAt>2025-10-29</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/1-2-claude-code-provider-implementation.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>developer</asA>
    <iWant>Claude Code implemented as first AI provider</iWant>
    <soThat>I can validate the provider abstraction with a real implementation</soThat>
    <tasks>
- [ ] Task 1: Implement Claude Code provider class structure (AC: 1)
  - [ ] Subtask 1.1: Create ClaudeCodeProvider class implementing IAIProvider
  - [ ] Subtask 1.2: Implement initialize() method with API key configuration
  - [ ] Subtask 1.3: Implement dispose() method for cleanup
- [ ] Task 2: Implement core message handling (AC: 1, 3)
  - [ ] Subtask 2.1: Implement sendMessage() method with streaming support
  - [ ] Subtask 2.2: Add MCP (Model Context Protocol) integration for tools
  - [ ] Subtask 2.3: Implement streaming response handler with chunk parsing
- [ ] Task 3: Add provider capabilities discovery (AC: 1)
  - [ ] Subtask 3.1: Implement getCapabilities() method
  - [ ] Subtask 3.2: Return Claude-specific capabilities (streaming, models, limits)
  - [ ] Subtask 3.3: Map Claude models to standardized capability format
- [ ] Task 4: Implement error handling and retry logic (AC: 4)
  - [ ] Subtask 4.1: Create Claude-specific error types for rate limits, timeouts
  - [ ] Subtask 4.2: Implement exponential backoff retry for transient failures
  - [ ] Subtask 4.3: Add context overflow and token limit handling
- [ ] Task 5: Add telemetry and monitoring (AC: 5)
  - [ ] Subtask 5.1: Implement telemetry hooks for latency tracking
  - [ ] Subtask 5.2: Add token usage monitoring
  - [ ] Subtask 5.3: Add error rate tracking and reporting
- [ ] Task 6: Create comprehensive test suite (AC: 5, 6)
  - [ ] Subtask 6.1: Write unit tests for happy path scenarios
  - [ ] Subtask 6.2: Write unit tests for error cases and edge cases
  - [ ] Subtask 6.3: Write integration test for end-to-end code generation
  - [ ] Subtask 6.4: Add tests for rate limiting and context limits
    </tasks>
  </story>

  <acceptanceCriteria>
1. Claude Code provider implements all interface operations from Story 1.1
2. Provider handles authentication via API key configuration
3. Provider supports streaming responses for real-time feedback
4. Provider includes retry logic with exponential backoff for transient failures
5. Unit tests cover happy path, error cases, and edge cases (context limits, rate limiting)
6. Integration test demonstrates end-to-end code generation request
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc path="docs/tech-spec-epic-1.md" title="Epic Technical Specification: Foundation & Core Infrastructure" section="Claude Code Provider" snippet="Implementation class: ClaudeCodeProvider implements IAIProvider. Uses MCP (Model Context Protocol) for tool integration. Streaming response handler with chunk parsing. Context management with conversation history. Error handling for rate limits, network failures, token limits. Telemetry hooks for latency, token usage, error rates.">
      </doc>
      <doc path="docs/epics.md" title="Tamma - Epic Breakdown" section="Story 1.2: Claude Code Provider Implementation" snippet="Claude Code provider implements all interface operations from Story 1.1. Provider handles authentication via API key configuration. Provider supports streaming responses for real-time feedback. Provider includes retry logic with exponential backoff for transient failures.">
      </doc>
      <doc path="docs/PRD.md" title="Tamma Product Requirements Document" section="AI Provider Integration" snippet="FR-7: System shall provide abstract interface supporting multiple AI providers with seamless provider switching. FR-8: System shall maintain provider feature matrix documentation for capability comparison. FR-9: System shall route tasks to optimal AI provider based on cost optimization and capability matching.">
      </doc>
      <doc path="docs/architecture.md" title="Tamma - Technical Architecture" section="Technology Stack" snippet="TypeScript 5.7+ strict mode, Node.js 22 LTS, pnpm workspaces. Interface-based design pattern and plugin architecture for extensibility.">
      </doc>
    </docs>
    <code>
      <!-- Reuse interfaces from story 1-1 - no existing implementation code yet -->
    </code>
    <dependencies>
      <ecosystem name="nodejs">
        <package name="@anthropic-ai/sdk" version="^0.20.0" reason="Anthropic Claude API client for provider implementation" />
        <package name="@modelcontextprotocol/sdk" version="^1.0.0" reason="MCP protocol for tool integration" />
        <package name="typescript" version="^5.7.0" reason="Type system and compiler for implementation" />
        <package name="zod" version="^3.22.0" reason="Runtime type validation for interface schemas" />
      </ecosystem>
      <ecosystem name="pnpm-workspace">
        <package name="@tamma/types" version="workspace:*" reason="Shared TypeScript types and interfaces (IAIProvider, etc.)" />
        <package name="@tamma/config" version="workspace:*" reason="Shared configuration management (ProviderConfig)" />
        <package name="@tamma/logger" version="workspace:*" reason="Shared logging infrastructure for telemetry" />
      </ecosystem>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint type="package-location">Implementation must be placed in packages/providers/src/claude-code-provider.ts following monorepo structure</constraint>
    <constraint type="typescript-config">Use TypeScript 5.7+ strict mode with proper interface implementation and error type definitions</constraint>
    <constraint type="naming-conventions">Follow established patterns: ClaudeCodeProvider class, error classes with descriptive names, proper method signatures matching IAIProvider</constraint>
    <constraint type="interface-implementation">Must implement all IAIProvider methods: initialize, sendMessage, getCapabilities, dispose</constraint>
    <constraint type="authentication">Provider must handle API key authentication through ProviderConfig interface</constraint>
    <constraint type="streaming-support">Must support streaming responses via AsyncIterable<MessageChunk> return type</constraint>
    <constraint type="error-handling">Must implement exponential backoff retry for transient failures with proper error types</constraint>
    <constraint type="mcp-integration">Must use MCP (Model Context Protocol) for tool integration</constraint>
    <constraint type="testing-requirements">Both unit and integration tests required to validate end-to-end functionality</constraint>
    <constraint type="telemetry">Must include telemetry hooks for latency, token usage, and error rate tracking</constraint>
  </constraints>
  <interfaces>
    <interface name="IAIProvider" kind="TypeScript interface" signature="interface IAIProvider { initialize(config: ProviderConfig): Promise<void>; sendMessage(request: MessageRequest): Promise<AsyncIterable<MessageChunk>>; getCapabilities(): ProviderCapabilities; dispose(): Promise<void>; }" path="packages/providers/src/types.ts">
    </interface>
    <interface name="MessageRequest" kind="TypeScript interface" signature="interface MessageRequest { messages: Message[]; systemPrompt?: string; tools?: Tool[]; maxTokens?: number; temperature?: number; model?: string; }" path="packages/providers/src/types.ts">
    </interface>
    <interface name="ProviderCapabilities" kind="TypeScript interface" signature="interface ProviderCapabilities { supportsStreaming: boolean; supportsTools: boolean; supportedModels: string[]; maxContextTokens: number; maxOutputTokens: number; }" path="packages/providers/src/types.ts">
    </interface>
    <interface name="Message" kind="TypeScript interface" signature="interface Message { role: 'system' | 'user' | 'assistant' | 'tool'; content: string; toolCallId?: string; toolCalls?: ToolCall[]; }" path="packages/providers/src/types.ts">
    </interface>
    <interface name="Tool" kind="TypeScript interface" signature="interface Tool { name: string; description: string; parameters: JSONSchema; }" path="packages/providers/src/types.ts">
    </interface>
    <interface name="MessageChunk" kind="TypeScript interface" signature="interface MessageChunk { type: 'text' | 'tool_call' | 'error'; content: string; delta?: string; done: boolean; }" path="packages/providers/src/types.ts">
    </interface>
    <interface name="ProviderConfig" kind="TypeScript interface" signature="interface ProviderConfig { providerId: string; providerType: 'claude-code' | 'copilot' | 'custom'; apiKey?: string; baseUrl?: string; model?: string; defaultParams?: { temperature?: number; maxTokens?: number; }; }" path="packages/providers/src/types.ts">
    </interface>
  </interfaces>
  <tests>
    <standards>Unit testing using Jest 29+ with TypeScript support. Mock external APIs (Anthropic, MCP) using MSW (Mock Service Worker). Line coverage: 80% minimum, branch coverage: 75% minimum, function coverage: 85% minimum. Critical paths (streaming, error handling, retry logic): 100% coverage. Integration tests with real API keys for end-to-end validation.</standards>
    <locations>packages/providers/src/**/*.test.ts, packages/providers/test/**/*.test.ts</locations>
    <ideas>
      <test idea="Test ClaudeCodeProvider implements IAIProvider interface" acceptanceCriteria="1">
        Verify all required methods exist with correct signatures and behavior
      </test>
      <test idea="Test API key authentication" acceptanceCriteria="2">
        Validate provider initialization with valid/invalid API keys
      </test>
      <test idea="Test streaming response handling" acceptanceCriteria="3">
        Verify AsyncIterable<MessageChunk> streaming works correctly with real-time feedback
      </test>
      <test idea="Test exponential backoff retry logic" acceptanceCriteria="4">
        Validate retry behavior for transient failures (network, rate limits)
      </test>
      <test idea="Test comprehensive error scenarios" acceptanceCriteria="5">
        Cover rate limits, timeouts, context overflow, network failures
      </test>
      <test idea="Test end-to-end code generation" acceptanceCriteria="6">
        Integration test demonstrating complete request/response cycle
      </test>
    </ideas>
  </tests>
</story-context>