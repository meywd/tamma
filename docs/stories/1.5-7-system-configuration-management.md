# Story 1.5-7: System Configuration Management

**Epic:** 1.5 - Deployment, Packaging & Operations  
**Status:** Ready for Development  
**Priority:** MVP Critical  
**Estimated Effort:** 4 days

## Overview

Implement unified configuration schema with environment-specific overrides, JSON Schema validation, configuration hot-reload support, and secrets management integration. System configuration management provides consistent configuration across all deployment modes (CLI, service, web, worker) with flexible loading from files, environment variables, and command-line arguments.

## Technical Context

### ⚠️ Development Process Reminder

**Before implementing this story, ensure you have:**
1. ✅ Read [BEFORE_YOU_CODE.md](../../BEFORE_YOU_CODE.md)
2. ✅ Searched `.dev/` directory for related spikes, bugs, findings, and decisions
3. ✅ Reviewed relevant documentation in `docs/` directory
4. ✅ Checked existing code patterns for similar functionality
5. ✅ Planned TDD approach (Red-Green-Refactor cycle)


Configuration management is critical for Tamma's flexibility across different deployment environments. The implementation must support multiple configuration sources (files, environment variables, CLI args), multiple formats (JSON, YAML, TOML), environment-specific overrides, and runtime configuration updates. The system must validate configurations against JSON schemas and provide helpful error messages for invalid configurations.

This story builds upon the configuration foundation from Epic 1 Stories 1-3 and 1-7, extending it to support all deployment modes and providing unified configuration management for the entire system.

## Acceptance Criteria

1. Configuration loaded from file, environment variables, and CLI args (in that order)
2. Supported formats: JSON, YAML, TOML
3. Environment-specific overrides (config.production.yaml, config.development.yaml)
4. JSON Schema validation with helpful error messages
5. Configuration hot-reload support (service mode restarts on config change)
6. Secrets management integration (environment variables, AWS Secrets Manager)
7. Configuration API for runtime updates
8. Unit tests validate config loading, merging, validation
9. Integration tests validate config loading in all deployment modes

## Implementation Details

### Configuration Package Structure

```
packages/
├── config/                  # @tamma/config - Shared configuration
│   ├── src/
│   │   ├── schema.ts        # JSON Schema definitions
│   │   ├── loader.ts        # Config loading/merging
│   │   ├── validator.ts     # Config validation
│   │   ├── merger.ts        # Config merging logic
│   │   ├── secrets.ts       # Secrets management
│   │   ├── watcher.ts       # File watching for hot-reload
│   │   ├── env.ts          # Environment variable handling
│   │   ├── cli.ts          # Command-line argument parsing
│   │   ├── types.ts        # Configuration types
│   │   └── index.ts        # Public API exports
│   ├── schemas/             # JSON Schema files
│   │   ├── base.schema.json
│   │   ├── ai-provider.schema.json
│   │   ├── git-platform.schema.json
│   │   ├── service.schema.json
│   │   ├── web-server.schema.json
│   │   ├── webhook.schema.json
│   │   └── docker.schema.json
│   ├── templates/           # Configuration templates
│   │   ├── config.yaml.template
│   │   ├── config.production.yaml.template
│   │   └── config.development.yaml.template
│   ├── tests/
│   │   ├── loader.test.ts
│   │   ├── validator.test.ts
│   │   ├── merger.test.ts
│   │   ├── secrets.test.ts
│   │   └── integration/
│   ├── package.json
│   └── tsconfig.json
```

### Configuration Types

```typescript
// @tamma/config/src/types.ts
import { z } from 'zod';

// Base configuration
export const BaseConfigSchema = z.object({
  // Core settings
  mode: z.enum(['cli', 'service', 'web', 'worker']),
  logLevel: z.enum(['error', 'warn', 'info', 'debug', 'trace']),

  // Environment
  environment: z.enum(['development', 'staging', 'production']).default('development'),

  // Data directories
  dataDir: z.string().default('./data'),
  cacheDir: z.string().default('./cache'),
  logDir: z.string().default('./logs'),
  workspaceDir: z.string().default('./workspace'),

  // Feature flags
  features: z
    .object({
      enableMetrics: z.boolean().default(true),
      enableTracing: z.boolean().default(false),
      enableProfiling: z.boolean().default(false),
      enableDebugMode: z.boolean().default(false),
    })
    .default({}),
});

// AI Provider configuration
export const AIProviderConfigSchema = z.object({
  default: z.string(),
  providers: z.array(
    z.object({
      name: z.string(),
      enabled: z.boolean(),
      apiKey: z.string().optional(),
      baseUrl: z.string().url().optional(),
      model: z.string().optional(),
      options: z.record(z.any()).optional(),
      timeout: z.number().min(1000).max(300000).default(60000),
      maxRetries: z.number().min(0).max(10).default(3),
      rateLimit: z
        .object({
          requestsPerMinute: z.number().min(1).max(1000).default(60),
          burstSize: z.number().min(1).max(100).default(10),
        })
        .optional(),
    })
  ),
  perWorkflowProviders: z.record(z.string()).optional(),
  fallbackChain: z.array(z.string()).optional(),
});

// Git Platform configuration
export const GitPlatformConfigSchema = z.object({
  default: z.string(),
  platforms: z.array(
    z.object({
      name: z.string(),
      enabled: z.boolean(),
      token: z.string().optional(),
      baseUrl: z.string().url().optional(),
      options: z.record(z.any()).optional(),
      timeout: z.number().min(1000).max(300000).default(30000),
      maxRetries: z.number().min(0).max(10).default(3),
      rateLimit: z
        .object({
          requestsPerMinute: z.number().min(1).max(1000).default(60),
          burstSize: z.number().min(1).max(100).default(10),
        })
        .optional(),
    })
  ),
  defaultBranch: z.string().default('main'),
  sshKeyPath: z.string().optional(),
  gitConfig: z.record(z.string()).optional(),
});

// Service mode configuration
export const ServiceConfigSchema = z.object({
  pollInterval: z.number().min(100).max(60000).default(5000),
  maxConcurrentTasks: z.number().min(1).max(20).default(3),
  maxRetries: z.number().min(0).max(10).default(3),
  retryDelay: z.number().min(100).max(300000).default(5000),
  maxRetryDelay: z.number().min(1000).max(3600000).default(300000),

  autoApprove: z
    .object({
      lowComplexity: z.boolean().default(true),
      mediumComplexity: z.boolean().default(false),
      maxEstimatedHours: z.number().min(1).max(40).default(8),
      blockFilePatterns: z
        .array(z.string())
        .default(['package.json', 'yarn.lock', 'package-lock.json', 'pnpm-lock.yaml']),
    })
    .default({}),

  escalation: z
    .object({
      enabled: z.boolean().default(true),
      channels: z.array(z.enum(['email', 'slack', 'teams', 'github'])).default(['github']),
      timeout: z.number().min(300).max(86400).default(3600),
    })
    .default({}),
});

// Web server configuration
export const WebServerConfigSchema = z.object({
  host: z.string().default('0.0.0.0'),
  port: z.number().min(1).max(65535).default(3000),
  trustProxy: z.boolean().default(false),
  bodyLimit: z.number().min(1024).max(10485760).default(1048576),

  jwtSecret: z.string().min(32),
  jwtExpiresIn: z.string().default('1h'),

  cors: z
    .object({
      origins: z.array(z.string()).default(['http://localhost:3000']),
      credentials: z.boolean().default(true),
      methods: z.array(z.string()).default(['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS']),
      headers: z.array(z.string()).default(['Content-Type', 'Authorization']),
    })
    .default({}),

  rateLimit: z
    .object({
      enabled: z.boolean().default(true),
      windowMs: z.number().min(1000).max(3600000).default(60000),
      max: z.number().min(1).max(10000).default(100),
      skipSuccessfulRequests: z.boolean().default(false),
    })
    .default({}),

  docs: z
    .object({
      enabled: z.boolean().default(true),
      path: z.string().default('/docs'),
      title: z.string().default('Tamma API Documentation'),
    })
    .default({}),
});

// Webhook configuration
export const WebhookConfigSchema = z.object({
  github: z
    .object({
      enabled: z.boolean().default(true),
      secret: z.string(),
      botUsername: z.string(),
      events: z
        .array(z.string())
        .default(['issues', 'issue_comment', 'pull_request', 'pull_request_review']),
    })
    .optional(),

  gitlab: z
    .object({
      enabled: z.boolean().default(false),
      token: z.string(),
      botUsername: z.string(),
      events: z.array(z.string()).default(['Issue Hook', 'Note Hook', 'Merge Request Hook']),
    })
    .optional(),

  filters: z
    .object({
      allowedRepositories: z.array(z.string()).optional(),
      blockedRepositories: z.array(z.string()).optional(),
      allowedUsers: z.array(z.string()).optional(),
      blockedUsers: z.array(z.string()).optional(),
      requireBotMention: z.boolean().default(true),
    })
    .default({}),

  processing: z
    .object({
      maxPayloadSize: z.number().min(1024).max(10485760).default(1048576),
      timeout: z.number().min(1000).max(30000).default(10000),
      retryAttempts: z.number().min(0).max(5).default(3),
    })
    .default({}),
});

// Database configuration
export const DatabaseConfigSchema = z.object({
  url: z.string().url(),
  ssl: z.boolean().default(true),
  poolSize: z.number().min(1).max(100).default(10),
  connectionTimeout: z.number().min(1000).max(30000).default(10000),
  idleTimeout: z.number().min(1000).max(300000).default(30000),
  maxLifetime: z.number().min(300000).max(3600000).default(1800000),
  migrations: z
    .object({
      autoRun: z.boolean().default(true),
      directory: z.string().default('./database/migrations'),
      table: z.string().default('schema_migrations'),
    })
    .default({}),
});

// Queue configuration
export const QueueConfigSchema = z.object({
  type: z.enum(['memory', 'redis', 'sqs']).default('memory'),

  redis: z
    .object({
      url: z.string().url(),
      keyPrefix: z.string().default('tamma:'),
      maxRetriesPerRequest: z.number().min(0).max(10).default(3),
      retryDelayOnFailover: z.number().min(100).max(10000).default(100),
      enableOfflineQueue: z.boolean().default(false),
      connectTimeout: z.number().min(1000).max(10000).default(10000),
      commandTimeout: z.number().min(1000).max(10000).default(5000),
      maxRetriesPerRequest: z.number().min(0).max(10).default(3),
    })
    .optional(),

  sqs: z
    .object({
      queueUrl: z.string(),
      region: z.string(),
      accessKeyId: z.string().optional(),
      secretAccessKey: z.string().optional(),
      sessionToken: z.string().optional(),
      maxRetries: z.number().min(0).max(10).default(3),
      visibilityTimeout: z.number().min(0).max(43200).default(30),
      messageRetentionPeriod: z.number().min(60).max(1209600).default(345600),
      receiveMessageWaitTime: z.number().min(0).max(20).default(20),
    })
    .optional(),

  memory: z
    .object({
      maxSize: z.number().min(100).max(10000).default(1000),
      cleanupInterval: z.number().min(1000).max(60000).default(30000),
    })
    .default({}),
});

// Complete configuration schema
export const TammaConfigSchema = z.object({
  ...BaseConfigSchema.shape,
  aiProvider: AIProviderConfigSchema,
  gitPlatform: GitPlatformConfigSchema,
  service: ServiceConfigSchema.optional(),
  web: WebServerConfigSchema.optional(),
  webhooks: WebhookConfigSchema.optional(),
  database: DatabaseConfigSchema.optional(),
  queue: QueueConfigSchema,
});

export type TammaConfig = z.infer<typeof TammaConfigSchema>;
export type BaseConfig = z.infer<typeof BaseConfigSchema>;
export type AIProviderConfig = z.infer<typeof AIProviderConfigSchema>;
export type GitPlatformConfig = z.infer<typeof GitPlatformConfigSchema>;
export type ServiceConfig = z.infer<typeof ServiceConfigSchema>;
export type WebServerConfig = z.infer<typeof WebServerConfigSchema>;
export type WebhookConfig = z.infer<typeof WebhookConfigSchema>;
export type DatabaseConfig = z.infer<typeof DatabaseConfigSchema>;
export type QueueConfig = z.infer<typeof QueueConfigSchema>;
```

### Configuration Loader

```typescript
// @tamma/config/src/loader.ts
import { promises as fs } from 'fs';
import { join, dirname, extname } from 'path';
import { homedir } from 'os';
import { TammaConfig, BaseConfig } from './types';
import { ConfigMerger } from './merger';
import { ConfigValidator } from './validator';
import { EnvironmentLoader } from './env';
import { CLILoader } from './cli';
import { SecretsManager } from './secrets';
import { ConfigWatcher } from './watcher';
import { createLogger, ILogger } from '@tamma/observability';

export interface LoadOptions {
  configPath?: string;
  environment?: string;
  mode?: string;
  enableHotReload?: boolean;
  secretsProvider?: 'env' | 'aws-secrets-manager' | 'vault';
}

export interface LoadResult {
  config: TammaConfig;
  sources: ConfigSource[];
  warnings: string[];
  errors: string[];
}

export interface ConfigSource {
  type: 'file' | 'environment' | 'cli' | 'secrets' | 'defaults';
  path?: string;
  loaded: boolean;
  error?: string;
}

export class ConfigLoader {
  private logger: ILogger;
  private merger: ConfigMerger;
  private validator: ConfigValidator;
  private envLoader: EnvironmentLoader;
  private cliLoader: CLILoader;
  private secretsManager: SecretsManager;
  private watcher?: ConfigWatcher;

  constructor() {
    this.logger = createLogger('config-loader');
    this.merger = new ConfigMerger();
    this.validator = new ConfigValidator();
    this.envLoader = new EnvironmentLoader();
    this.cliLoader = new CLILoader();
    this.secretsManager = new SecretsManager();
  }

  async load(options: LoadOptions = {}): Promise<LoadResult> {
    const startTime = Date.now();
    const sources: ConfigSource[] = [];
    const warnings: string[] = [];
    const errors: string[] = [];

    try {
      this.logger.info('Loading configuration', { options });

      // 1. Load default configuration
      const defaultConfig = this.getDefaultConfig();
      sources.push({
        type: 'defaults',
        loaded: true,
      });

      // 2. Load configuration file(s)
      const fileConfig = await this.loadConfigFiles(options, sources, warnings);

      // 3. Load environment-specific configuration
      const envSpecificConfig = await this.loadEnvironmentSpecificConfig(
        options.environment || process.env.NODE_ENV || 'development',
        options.configPath,
        sources,
        warnings
      );

      // 4. Load environment variables
      const envConfig = await this.envLoader.load();
      sources.push({
        type: 'environment',
        loaded: true,
      });

      // 5. Load secrets
      const secretsConfig = await this.secretsManager.load(options.secretsProvider);
      sources.push({
        type: 'secrets',
        loaded: true,
      });

      // 6. Load command-line arguments
      const cliConfig = await this.cliLoader.load();
      sources.push({
        type: 'cli',
        loaded: true,
      });

      // 7. Merge configurations in order of precedence
      const mergedConfig = this.merger.merge([
        defaultConfig,
        fileConfig,
        envSpecificConfig,
        envConfig,
        secretsConfig,
        cliConfig,
      ]);

      // 8. Apply mode-specific overrides
      const finalConfig = this.applyModeOverrides(mergedConfig, options.mode);

      // 9. Validate final configuration
      const validationResult = await this.validator.validate(finalConfig);

      if (!validationResult.valid) {
        errors.push(...validationResult.errors);
        this.logger.error('Configuration validation failed', {
          errors: validationResult.errors,
        });
      }

      if (validationResult.warnings.length > 0) {
        warnings.push(...validationResult.warnings);
        this.logger.warn('Configuration validation warnings', {
          warnings: validationResult.warnings,
        });
      }

      // 10. Set up hot-reload if enabled
      if (options.enableHotReload && (options.configPath || this.getDefaultConfigPath())) {
        this.setupHotReload(options.configPath || this.getDefaultConfigPath(), finalConfig);
      }

      const loadTime = Date.now() - startTime;
      this.logger.info('Configuration loaded successfully', {
        loadTime,
        sources: sources.length,
        warnings: warnings.length,
        errors: errors.length,
      });

      return {
        config: finalConfig,
        sources,
        warnings,
        errors,
      };
    } catch (error) {
      const loadTime = Date.now() - startTime;
      this.logger.error('Configuration loading failed', {
        error: error.message,
        stack: error.stack,
        loadTime,
      });

      errors.push(`Configuration loading failed: ${error.message}`);

      return {
        config: this.getDefaultConfig(),
        sources,
        warnings,
        errors,
      };
    }
  }

  private getDefaultConfig(): Partial<TammaConfig> {
    return {
      mode: 'cli',
      logLevel: 'info',
      environment: 'development',
      dataDir: './data',
      cacheDir: './cache',
      logDir: './logs',
      workspaceDir: './workspace',
      features: {
        enableMetrics: true,
        enableTracing: false,
        enableProfiling: false,
        enableDebugMode: false,
      },
      aiProvider: {
        default: 'anthropic-claude',
        providers: [
          {
            name: 'anthropic-claude',
            enabled: true,
            model: 'claude-3-5-sonnet-20241022',
            timeout: 60000,
            maxRetries: 3,
          },
        ],
      },
      gitPlatform: {
        default: 'github',
        platforms: [
          {
            name: 'github',
            enabled: true,
            timeout: 30000,
            maxRetries: 3,
          },
        ],
        defaultBranch: 'main',
      },
      queue: {
        type: 'memory',
        memory: {
          maxSize: 1000,
          cleanupInterval: 30000,
        },
      },
    };
  }

  private async loadConfigFiles(
    options: LoadOptions,
    sources: ConfigSource[],
    warnings: string[]
  ): Promise<Partial<TammaConfig>> {
    const configPath = options.configPath || this.getDefaultConfigPath();

    if (!configPath) {
      return {};
    }

    try {
      const config = await this.loadConfigFile(configPath);
      sources.push({
        type: 'file',
        path: configPath,
        loaded: true,
      });

      return config;
    } catch (error) {
      sources.push({
        type: 'file',
        path: configPath,
        loaded: false,
        error: error.message,
      });

      warnings.push(`Failed to load config file ${configPath}: ${error.message}`);
      return {};
    }
  }

  private async loadEnvironmentSpecificConfig(
    environment: string,
    configPath: string | undefined,
    sources: ConfigSource[],
    warnings: string[]
  ): Promise<Partial<TammaConfig>> {
    if (!configPath) {
      return {};
    }

    const envConfigPath = this.getEnvironmentSpecificConfigPath(configPath, environment);

    try {
      const config = await this.loadConfigFile(envConfigPath);
      sources.push({
        type: 'file',
        path: envConfigPath,
        loaded: true,
      });

      return config;
    } catch (error) {
      // Environment-specific config is optional
      if (error.code !== 'ENOENT') {
        warnings.push(`Failed to load environment config ${envConfigPath}: ${error.message}`);
      }

      return {};
    }
  }

  private async loadConfigFile(configPath: string): Promise<Partial<TammaConfig>> {
    const content = await fs.readFile(configPath, 'utf-8');
    const ext = extname(configPath).toLowerCase();

    switch (ext) {
      case '.json':
        return JSON.parse(content);

      case '.yaml':
      case '.yml':
        return await this.parseYAML(content);

      case '.toml':
        return await this.parseTOML(content);

      default:
        throw new Error(`Unsupported config file format: ${ext}`);
    }
  }

  private async parseYAML(content: string): Promise<any> {
    // Dynamic import to avoid bundling issues
    const yaml = await import('yaml');
    return yaml.parse(content);
  }

  private async parseTOML(content: string): Promise<any> {
    // Dynamic import to avoid bundling issues
    const toml = await import('toml');
    return toml.parse(content);
  }

  private getDefaultConfigPath(): string | null {
    const possiblePaths = [
      join(process.cwd(), 'tamma.config.yaml'),
      join(process.cwd(), 'tamma.config.yml'),
      join(process.cwd(), 'tamma.config.json'),
      join(process.cwd(), 'tamma.config.toml'),
      join(process.cwd(), '.tamma', 'config.yaml'),
      join(process.cwd(), '.tamma', 'config.yml'),
      join(process.cwd(), '.tamma', 'config.json'),
      join(process.cwd(), '.tamma', 'config.toml'),
      join(homedir(), '.tamma', 'config.yaml'),
      join(homedir(), '.tamma', 'config.yml'),
      join(homedir(), '.tamma', 'config.json'),
      join(homedir(), '.tamma', 'config.toml'),
    ];

    for (const path of possiblePaths) {
      try {
        await fs.access(path);
        return path;
      } catch {
        // File doesn't exist, continue
      }
    }

    return null;
  }

  private getEnvironmentSpecificConfigPath(basePath: string, environment: string): string {
    const dir = dirname(basePath);
    const name = basename(basePath, extname(basePath));
    const ext = extname(basePath);

    return join(dir, `${name}.${environment}${ext}`);
  }

  private applyModeOverrides(config: Partial<TammaConfig>, mode?: string): Partial<TammaConfig> {
    if (!mode) {
      return config;
    }

    // Apply mode-specific defaults and overrides
    switch (mode) {
      case 'cli':
        return {
          ...config,
          logLevel: config.logLevel || 'info',
          features: {
            ...config.features,
            enableDebugMode: process.env.DEBUG === 'true',
          },
        };

      case 'service':
        return {
          ...config,
          logLevel: config.logLevel || 'info',
          service: {
            ...config.service,
            pollInterval: config.service?.pollInterval || 5000,
            maxConcurrentTasks: config.service?.maxConcurrentTasks || 3,
          },
        };

      case 'web':
        return {
          ...config,
          logLevel: config.logLevel || 'info',
          web: {
            ...config.web,
            host: config.web?.host || '0.0.0.0',
            port: config.web?.port || 3000,
          },
        };

      case 'worker':
        return {
          ...config,
          logLevel: config.logLevel || 'info',
          queue: {
            ...config.queue,
            type: config.queue?.type || 'redis',
          },
        };

      default:
        return config;
    }
  }

  private setupHotReload(configPath: string, currentConfig: TammaConfig): void {
    this.watcher = new ConfigWatcher();

    this.watcher.on('change', async (filePath: string) => {
      this.logger.info('Configuration file changed, reloading', { filePath });

      try {
        const result = await this.load({
          configPath,
          enableHotReload: true,
        });

        if (result.errors.length === 0) {
          this.logger.info('Configuration reloaded successfully');
          // Emit event for other components to handle the change
          this.emit('configReloaded', result.config);
        } else {
          this.logger.error('Configuration reload failed', {
            errors: result.errors,
          });
        }
      } catch (error) {
        this.logger.error('Failed to reload configuration', { error });
      }
    });

    this.watcher.watch(configPath);
  }

  async save(config: TammaConfig, configPath?: string): Promise<void> {
    const path = configPath || this.getDefaultConfigPath();

    if (!path) {
      throw new Error('No configuration path specified and no default path found');
    }

    const ext = extname(path).toLowerCase();
    let content: string;

    switch (ext) {
      case '.json':
        content = JSON.stringify(config, null, 2);
        break;

      case '.yaml':
      case '.yml':
        const yaml = await import('yaml');
        content = yaml.stringify(config);
        break;

      case '.toml':
        const toml = await import('toml');
        content = toml.stringify(config);
        break;

      default:
        throw new Error(`Unsupported config file format: ${ext}`);
    }

    // Ensure directory exists
    await fs.mkdir(dirname(path), { recursive: true });

    // Write configuration
    await fs.writeFile(path, content, 'utf-8');

    this.logger.info('Configuration saved', { path });
  }

  async validate(config: Partial<TammaConfig>): Promise<{
    valid: boolean;
    errors: string[];
    warnings: string[];
  }> {
    return await this.validator.validate(config);
  }

  stop(): void {
    if (this.watcher) {
      this.watcher.stop();
      this.watcher = undefined;
    }
  }
}

// Export singleton instance
export const configLoader = new ConfigLoader();

// Convenience function
export async function loadConfig(options?: LoadOptions): Promise<TammaConfig> {
  const result = await configLoader.load(options);

  if (result.errors.length > 0) {
    throw new Error(`Configuration errors: ${result.errors.join(', ')}`);
  }

  return result.config;
}
```

### Configuration Validator

```typescript
// @tamma/config/src/validator.ts
import { TammaConfigSchema, TammaConfig } from './types';
import { createLogger, ILogger } from '@tamma/observability';

export interface ValidationResult {
  valid: boolean;
  errors: string[];
  warnings: string[];
}

export class ConfigValidator {
  private logger: ILogger;

  constructor() {
    this.logger = createLogger('config-validator');
  }

  async validate(config: Partial<TammaConfig>): Promise<ValidationResult> {
    const errors: string[] = [];
    const warnings: string[] = [];

    try {
      // Validate against Zod schema
      const result = TammaConfigSchema.safeParse(config);

      if (!result.success) {
        // Format Zod errors
        for (const error of result.error.issues) {
          const path = error.path.join('.');
          const message = this.formatZodError(error);

          if (error.code === 'invalid_type') {
            errors.push(`Invalid type for ${path}: ${message}`);
          } else if (error.code === 'invalid_enum_value') {
            errors.push(`Invalid value for ${path}: ${message}`);
          } else if (error.code === 'too_small' || error.code === 'too_big') {
            errors.push(`Invalid value for ${path}: ${message}`);
          } else {
            errors.push(`${path}: ${message}`);
          }
        }
      }

      // Additional validation logic
      await this.validateBusinessRules(config, errors, warnings);

      // Security validations
      await this.validateSecurity(config, errors, warnings);

      // Performance validations
      await this.validatePerformance(config, warnings);

      this.logger.debug('Configuration validation completed', {
        valid: errors.length === 0,
        errors: errors.length,
        warnings: warnings.length,
      });

      return {
        valid: errors.length === 0,
        errors,
        warnings,
      };
    } catch (error) {
      this.logger.error('Configuration validation error', { error });

      return {
        valid: false,
        errors: [`Validation error: ${error.message}`],
        warnings,
      };
    }
  }

  private formatZodError(error: any): string {
    switch (error.code) {
      case 'invalid_type':
        return `expected ${error.expected}, got ${error.received}`;

      case 'invalid_enum_value':
        return `invalid value, expected one of: ${error.options.join(', ')}`;

      case 'too_small':
        return error.type === 'string'
          ? `must be at least ${error.minimum} characters`
          : `must be at least ${error.minimum}`;

      case 'too_big':
        return error.type === 'string'
          ? `must be at most ${error.maximum} characters`
          : `must be at most ${error.maximum}`;

      case 'invalid_string':
        return `invalid format`;

      default:
        return error.message || 'validation error';
    }
  }

  private async validateBusinessRules(
    config: Partial<TammaConfig>,
    errors: string[],
    warnings: string[]
  ): Promise<void> {
    // Validate AI provider configuration
    if (config.aiProvider) {
      const defaultProvider = config.aiProvider.providers?.find(
        (p) => p.name === config.aiProvider?.default
      );

      if (!defaultProvider) {
        errors.push(
          `Default AI provider '${config.aiProvider.default}' not found in providers list`
        );
      }

      if (defaultProvider && !defaultProvider.enabled) {
        errors.push(`Default AI provider '${config.aiProvider.default}' is disabled`);
      }

      // Check for API keys
      for (const provider of config.aiProvider.providers || []) {
        if (provider.enabled && !provider.apiKey && !this.hasEnvVarForProvider(provider.name)) {
          warnings.push(`AI provider '${provider.name}' is enabled but no API key configured`);
        }
      }
    }

    // Validate Git platform configuration
    if (config.gitPlatform) {
      const defaultPlatform = config.gitPlatform.platforms?.find(
        (p) => p.name === config.gitPlatform?.default
      );

      if (!defaultPlatform) {
        errors.push(
          `Default Git platform '${config.gitPlatform.default}' not found in platforms list`
        );
      }

      if (defaultPlatform && !defaultPlatform.enabled) {
        errors.push(`Default Git platform '${config.gitPlatform.default}' is disabled`);
      }

      // Check for tokens
      for (const platform of config.gitPlatform.platforms || []) {
        if (platform.enabled && !platform.token && !this.hasEnvVarForPlatform(platform.name)) {
          warnings.push(`Git platform '${platform.name}' is enabled but no token configured`);
        }
      }
    }

    // Validate mode-specific requirements
    if (config.mode === 'web' && !config.web?.jwtSecret) {
      errors.push('Web server mode requires JWT secret');
    }

    if (config.mode === 'service' && !config.queue) {
      errors.push('Service mode requires queue configuration');
    }

    // Validate webhook configuration
    if (config.webhooks?.github?.enabled && !config.webhooks.github.secret) {
      errors.push('GitHub webhooks enabled but no secret configured');
    }

    if (config.webhooks?.gitlab?.enabled && !config.webhooks.gitlab.token) {
      errors.push('GitLab webhooks enabled but no token configured');
    }
  }

  private async validateSecurity(
    config: Partial<TammaConfig>,
    errors: string[],
    warnings: string[]
  ): Promise<void> {
    // Check for weak secrets
    if (config.web?.jwtSecret && config.web.jwtSecret.length < 32) {
      errors.push('JWT secret must be at least 32 characters long');
    }

    if (config.webhooks?.github?.secret && config.webhooks.github.secret.length < 16) {
      warnings.push('GitHub webhook secret should be at least 16 characters long');
    }

    // Check for insecure configurations
    if (config.web?.cors?.origins?.includes('*')) {
      warnings.push('CORS origins includes "*" which may be insecure');
    }

    if (config.web?.trustProxy && config.web.host === '0.0.0.0') {
      warnings.push('Trust proxy enabled with host "0.0.0.0" may be insecure');
    }

    // Check for exposed credentials in configuration
    const configStr = JSON.stringify(config);
    const credentialPatterns = [
      /sk-[a-zA-Z0-9]{20,}/, // Anthropic API key
      /ghp_[a-zA-Z0-9]{36}/, // GitHub token
      /glpat-[a-zA-Z0-9_-]{20}/, // GitLab token
    ];

    for (const pattern of credentialPatterns) {
      if (pattern.test(configStr)) {
        warnings.push('Configuration may contain exposed credentials');
        break;
      }
    }
  }

  private async validatePerformance(
    config: Partial<TammaConfig>,
    warnings: string[]
  ): Promise<void> {
    // Check for potentially performance-impacting settings
    if (config.service?.maxConcurrentTasks && config.service.maxConcurrentTasks > 10) {
      warnings.push('High concurrent task count may impact performance');
    }

    if (config.queue?.type === 'memory' && config.service?.maxConcurrentTasks > 5) {
      warnings.push('Memory queue with high concurrency may cause memory issues');
    }

    if (config.logLevel === 'debug' && config.environment === 'production') {
      warnings.push('Debug logging in production may impact performance');
    }

    if (config.features?.enableProfiling && config.environment === 'production') {
      warnings.push('Profiling enabled in production may impact performance');
    }
  }

  private hasEnvVarForProvider(providerName: string): boolean {
    const envVarMap: Record<string, string> = {
      'anthropic-claude': 'ANTHROPIC_API_KEY',
      openai: 'OPENAI_API_KEY',
      'github-copilot': 'GITHUB_TOKEN',
      'google-gemini': 'GOOGLE_AI_API_KEY',
    };

    const envVar = envVarMap[providerName];
    return envVar ? !!process.env[envVar] : false;
  }

  private hasEnvVarForPlatform(platformName: string): boolean {
    const envVarMap: Record<string, string> = {
      github: 'GITHUB_TOKEN',
      gitlab: 'GITLAB_TOKEN',
      bitbucket: 'BITBUCKET_TOKEN',
    };

    const envVar = envVarMap[platformName];
    return envVar ? !!process.env[envVar] : false;
  }
}
```

### Environment Variable Loader

```typescript
// @tamma/config/src/env.ts
import { createLogger, ILogger } from '@tamma/observability';

export class EnvironmentLoader {
  private logger: ILogger;

  constructor() {
    this.logger = createLogger('env-loader');
  }

  async load(): Promise<Partial<any>> {
    const config: any = {};

    // Core configuration
    if (process.env.TAMMA_MODE) {
      config.mode = process.env.TAMMA_MODE;
    }

    if (process.env.TAMMA_LOG_LEVEL) {
      config.logLevel = process.env.TAMMA_LOG_LEVEL;
    }

    if (process.env.NODE_ENV) {
      config.environment = process.env.NODE_ENV;
    }

    // AI Provider configuration
    if (process.env.TAMMA_AI_PROVIDER) {
      config.aiProvider = config.aiProvider || {};
      config.aiProvider.default = process.env.TAMMA_AI_PROVIDER;
    }

    // Git Platform configuration
    if (process.env.TAMMA_GIT_PLATFORM) {
      config.gitPlatform = config.gitPlatform || {};
      config.gitPlatform.default = process.env.TAMMA_GIT_PLATFORM;
    }

    // Database configuration
    if (process.env.DATABASE_URL) {
      config.database = config.database || {};
      config.database.url = process.env.DATABASE_URL;
    }

    // Queue configuration
    if (process.env.TAMMA_QUEUE_TYPE) {
      config.queue = config.queue || {};
      config.queue.type = process.env.TAMMA_QUEUE_TYPE;
    }

    if (process.env.REDIS_URL) {
      config.queue = config.queue || {};
      config.queue.redis = config.queue.redis || {};
      config.queue.redis.url = process.env.REDIS_URL;
    }

    // Web server configuration
    if (process.env.TAMMA_WEB_HOST) {
      config.web = config.web || {};
      config.web.host = process.env.TAMMA_WEB_HOST;
    }

    if (process.env.TAMMA_WEB_PORT) {
      config.web = config.web || {};
      config.web.port = parseInt(process.env.TAMMA_WEB_PORT, 10);
    }

    if (process.env.JWT_SECRET) {
      config.web = config.web || {};
      config.web.jwtSecret = process.env.JWT_SECRET;
    }

    // Service configuration
    if (process.env.TAMMA_SERVICE_POLL_INTERVAL) {
      config.service = config.service || {};
      config.service.pollInterval = parseInt(process.env.TAMMA_SERVICE_POLL_INTERVAL, 10);
    }

    if (process.env.TAMMA_SERVICE_MAX_CONCURRENT_TASKS) {
      config.service = config.service || {};
      config.service.maxConcurrentTasks = parseInt(
        process.env.TAMMA_SERVICE_MAX_CONCURRENT_TASKS,
        10
      );
    }

    // Webhook configuration
    if (process.env.GITHUB_WEBHOOK_SECRET) {
      config.webhooks = config.webhooks || {};
      config.webhooks.github = config.webhooks.github || {};
      config.webhooks.github.secret = process.env.GITHUB_WEBHOOK_SECRET;
    }

    if (process.env.GITLAB_WEBHOOK_TOKEN) {
      config.webhooks = config.webhooks || {};
      config.webhooks.gitlab = config.webhooks.gitlab || {};
      config.webhooks.gitlab.token = process.env.GITLAB_WEBHOOK_TOKEN;
    }

    if (process.env.TAMMA_WEBHOOK_BOT_USERNAME) {
      config.webhooks = config.webhooks || {};
      if (config.webhooks.github) {
        config.webhooks.github.botUsername = process.env.TAMMA_WEBHOOK_BOT_USERNAME;
      }
      if (config.webhooks.gitlab) {
        config.webhooks.gitlab.botUsername = process.env.TAMMA_WEBHOOK_BOT_USERNAME;
      }
    }

    this.logger.debug('Environment variables loaded', {
      keys: Object.keys(config),
    });

    return config;
  }
}
```

### Configuration Templates

```yaml
# @tamma/config/templates/config.yaml.template
# Tamma Configuration Template
# Copy this file to config.yaml and customize for your environment

# Core configuration
mode: cli  # cli, service, web, worker
logLevel: info  # error, warn, info, debug, trace
environment: development  # development, staging, production

# Data directories
dataDir: ./data
cacheDir: ./cache
logDir: ./logs
workspaceDir: ./workspace

# Feature flags
features:
  enableMetrics: true
  enableTracing: false
  enableProfiling: false
  enableDebugMode: false

# AI Provider configuration
aiProvider:
  default: anthropic-claude
  providers:
    - name: anthropic-claude
      enabled: true
      apiKey: ${ANTHROPIC_API_KEY}
      model: claude-3-5-sonnet-20241022
      timeout: 60000
      maxRetries: 3
      rateLimit:
        requestsPerMinute: 60
        burstSize: 10
    - name: openai
      enabled: false
      apiKey: ${OPENAI_API_KEY}
      model: gpt-4o
      timeout: 60000
      maxRetries: 3
  perWorkflowProviders:
    issue-analysis: anthropic-claude
    code-generation: anthropic-claude
    test-generation: openai
    code-review: anthropic-claude

# Git Platform configuration
gitPlatform:
  default: github
  platforms:
    - name: github
      enabled: true
      token: ${GITHUB_TOKEN}
      timeout: 30000
      maxRetries: 3
      rateLimit:
        requestsPerMinute: 60
        burstSize: 10
    - name: gitlab
      enabled: false
      token: ${GITLAB_TOKEN}
      baseUrl: https://gitlab.com
      timeout: 30000
      maxRetries: 3
  defaultBranch: main

# Service mode configuration (only used in service mode)
service:
  pollInterval: 5000
  maxConcurrentTasks: 3
  maxRetries: 3
  retryDelay: 5000
  maxRetryDelay: 300000
  autoApprove:
    lowComplexity: true
    mediumComplexity: false
    maxEstimatedHours: 8
    blockFilePatterns:
      - package.json
      - yarn.lock
      - package-lock.json
      - pnpm-lock.yaml
  escalation:
    enabled: true
    channels:
      - github
    timeout: 3600

# Web server configuration (only used in web mode)
web:
  host: 0.0.0.0
  port: 3000
  trustProxy: false
  bodyLimit: 1048576
  jwtSecret: ${JWT_SECRET}
  jwtExpiresIn: 1h
  cors:
    origins:
      - http://localhost:3000
    credentials: true
    methods:
      - GET
      - POST
      - PUT
      - DELETE
      - OPTIONS
    headers:
      - Content-Type
      - Authorization
  rateLimit:
    enabled: true
    windowMs: 60000
    max: 100
    skipSuccessfulRequests: false
  docs:
    enabled: true
    path: /docs
    title: Tamma API Documentation

# Webhook configuration
webhooks:
  github:
    enabled: true
    secret: ${GITHUB_WEBHOOK_SECRET}
    botUsername: tamma-bot
    events:
      - issues
      - issue_comment
      - pull_request
      - pull_request_review
  gitlab:
    enabled: false
    token: ${GITLAB_WEBHOOK_TOKEN}
    botUsername: tamma-bot
    events:
      - Issue Hook
      - Note Hook
      - Merge Request Hook
  filters:
    allowedRepositories: []
    blockedRepositories: []
    allowedUsers: []
    blockedUsers: []
    requireBotMention: true
  processing:
    maxPayloadSize: 1048576
    timeout: 10000
    retryAttempts: 3

# Database configuration (optional)
database:
  url: ${DATABASE_URL}
  ssl: true
  poolSize: 10
  connectionTimeout: 10000
  idleTimeout: 30000
  maxLifetime: 1800000
  migrations:
    autoRun: true
    directory: ./database/migrations
    table: schema_migrations

# Queue configuration
queue:
  type: memory  # memory, redis, sqs
  memory:
    maxSize: 1000
    cleanupInterval: 30000
  redis:
    url: ${REDIS_URL}
    keyPrefix: tamma:
    maxRetriesPerRequest: 3
    retryDelayOnFailover: 100
    enableOfflineQueue: false
    connectTimeout: 10000
    commandTimeout: 5000
  sqs:
    queueUrl: ${SQS_QUEUE_URL}
    region: ${AWS_REGION}
    accessKeyId: ${AWS_ACCESS_KEY_ID}
    secretAccessKey: ${AWS_SECRET_ACCESS_KEY}
    maxRetries: 3
    visibilityTimeout: 30
    messageRetentionPeriod: 345600
    receiveMessageWaitTime: 20
```

## Testing Strategy

### Unit Tests

```typescript
// @tamma/config/tests/loader.test.ts
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { ConfigLoader } from '../../src/loader';
import { promises as fs } from 'fs';
import { join } from 'path';

describe('ConfigLoader', () => {
  let loader: ConfigLoader;
  let tempDir: string;

  beforeEach(async () => {
    loader = new ConfigLoader();
    tempDir = await fs.mkdtemp('/tmp/tamma-config-test-');
  });

  afterEach(async () => {
    loader.stop();
    await fs.rmdir(tempDir, { recursive: true });
  });

  describe('configuration loading', () => {
    it('should load default configuration', async () => {
      const result = await loader.load();

      expect(result.config).toBeDefined();
      expect(result.config.mode).toBe('cli');
      expect(result.config.logLevel).toBe('info');
      expect(result.errors).toHaveLength(0);
    });

    it('should load configuration from YAML file', async () => {
      const configPath = join(tempDir, 'config.yaml');
      const configContent = `
mode: service
logLevel: debug
aiProvider:
  default: openai
  providers:
    - name: openai
      enabled: true
      apiKey: test-key
`;

      await fs.writeFile(configPath, configContent);

      const result = await loader.load({ configPath });

      expect(result.config.mode).toBe('service');
      expect(result.config.logLevel).toBe('debug');
      expect(result.config.aiProvider.default).toBe('openai');
      expect(result.sources).toContainEqual({
        type: 'file',
        path: configPath,
        loaded: true,
      });
    });

    it('should load configuration from JSON file', async () => {
      const configPath = join(tempDir, 'config.json');
      const configContent = {
        mode: 'web',
        logLevel: 'warn',
        web: {
          port: 8080,
        },
      };

      await fs.writeFile(configPath, JSON.stringify(configContent));

      const result = await loader.load({ configPath });

      expect(result.config.mode).toBe('web');
      expect(result.config.logLevel).toBe('warn');
      expect(result.config.web.port).toBe(8080);
    });

    it('should load environment-specific configuration', async () => {
      const configPath = join(tempDir, 'config.yaml');
      const envConfigPath = join(tempDir, 'config.production.yaml');

      await fs.writeFile(configPath, 'mode: cli\nlogLevel: info');
      await fs.writeFile(envConfigPath, 'mode: service\nlogLevel: error');

      const result = await loader.load({
        configPath,
        environment: 'production',
      });

      expect(result.config.mode).toBe('service');
      expect(result.config.logLevel).toBe('error');
    });

    it('should merge configurations in correct order', async () => {
      const configPath = join(tempDir, 'config.yaml');
      const configContent = `
mode: cli
logLevel: info
aiProvider:
  default: anthropic-claude
  providers:
    - name: anthropic-claude
      enabled: true
      timeout: 30000
`;

      await fs.writeFile(configPath, configContent);

      // Mock environment variables
      vi.stubEnv('TAMMA_LOG_LEVEL', 'debug');
      vi.stubEnv('TAMMA_SERVICE_POLL_INTERVAL', '10000');

      const result = await loader.load({ configPath });

      expect(result.config.mode).toBe('cli'); // from file
      expect(result.config.logLevel).toBe('debug'); // from env (overrides file)
      expect(result.config.service?.pollInterval).toBe(10000); // from env
      expect(result.config.aiProvider.default).toBe('anthropic-claude'); // from file
    });

    it('should handle missing configuration file gracefully', async () => {
      const result = await loader.load({
        configPath: join(tempDir, 'nonexistent.yaml'),
      });

      expect(result.config).toBeDefined();
      expect(result.sources).toContainEqual({
        type: 'file',
        path: join(tempDir, 'nonexistent.yaml'),
        loaded: false,
        error: expect.stringContaining('ENOENT'),
      });
      expect(result.warnings).toContainEqual(expect.stringContaining('Failed to load config file'));
    });
  });

  describe('configuration validation', () => {
    it('should validate valid configuration', async () => {
      const configPath = join(tempDir, 'config.yaml');
      const configContent = `
mode: service
logLevel: info
aiProvider:
  default: anthropic-claude
  providers:
    - name: anthropic-claude
      enabled: true
      apiKey: test-key
web:
  jwtSecret: test-jwt-secret-at-least-32-characters-long
  port: 3000
`;

      await fs.writeFile(configPath, configContent);

      const result = await loader.load({ configPath });

      expect(result.errors).toHaveLength(0);
      expect(result.config).toBeDefined();
    });

    it('should reject invalid configuration', async () => {
      const configPath = join(tempDir, 'config.yaml');
      const configContent = `
mode: invalid-mode
logLevel: invalid-level
aiProvider:
  default: nonexistent-provider
  providers: []
web:
  jwtSecret: short
`;

      await fs.writeFile(configPath, configContent);

      const result = await loader.load({ configPath });

      expect(result.errors.length).toBeGreaterThan(0);
      expect(result.errors).toContainEqual(expect.stringContaining('Invalid value for mode'));
      expect(result.errors).toContainEqual(expect.stringContaining('Invalid value for logLevel'));
    });

    it('should provide helpful validation errors', async () => {
      const configPath = join(tempDir, 'config.yaml');
      const configContent = `
mode: web
web:
  port: 99999  # Invalid port
  jwtSecret: short  # Too short
`;

      await fs.writeFile(configPath, configContent);

      const result = await loader.load({ configPath });

      expect(result.errors).toContainEqual(expect.stringContaining('Invalid value for web.port'));
      expect(result.errors).toContainEqual(
        expect.stringContaining('JWT secret must be at least 32 characters long')
      );
    });
  });

  describe('hot reload', () => {
    it('should watch configuration file for changes', async () => {
      const configPath = join(tempDir, 'config.yaml');
      const configContent = 'mode: cli\nlogLevel: info';

      await fs.writeFile(configPath, configContent);

      let reloadCount = 0;
      loader.on('configReloaded', () => {
        reloadCount++;
      });

      await loader.load({ configPath, enableHotReload: true });

      // Modify configuration file
      const newConfigContent = 'mode: service\nlogLevel: debug';
      await fs.writeFile(configPath, newConfigContent);

      // Wait for file watcher to detect change
      await new Promise((resolve) => setTimeout(resolve, 100));

      expect(reloadCount).toBe(1);
    });
  });
});
```

## Configuration

### Environment Variable Mapping

```typescript
// @tamma/config/src/env-mapping.ts
export const ENV_VAR_MAPPING = {
  // Core configuration
  TAMMA_MODE: 'mode',
  TAMMA_LOG_LEVEL: 'logLevel',
  NODE_ENV: 'environment',

  // AI Provider
  TAMMA_AI_PROVIDER: 'aiProvider.default',
  ANTHROPIC_API_KEY: 'aiProvider.providers[0].apiKey',
  OPENAI_API_KEY: 'aiProvider.providers[1].apiKey',

  // Git Platform
  TAMMA_GIT_PLATFORM: 'gitPlatform.default',
  GITHUB_TOKEN: 'gitPlatform.platforms[0].token',
  GITLAB_TOKEN: 'gitPlatform.platforms[1].token',

  // Web Server
  TAMMA_WEB_HOST: 'web.host',
  TAMMA_WEB_PORT: 'web.port',
  JWT_SECRET: 'web.jwtSecret',

  // Service
  TAMMA_SERVICE_POLL_INTERVAL: 'service.pollInterval',
  TAMMA_SERVICE_MAX_CONCURRENT_TASKS: 'service.maxConcurrentTasks',

  // Database
  DATABASE_URL: 'database.url',

  // Queue
  TAMMA_QUEUE_TYPE: 'queue.type',
  REDIS_URL: 'queue.redis.url',

  // Webhooks
  GITHUB_WEBHOOK_SECRET: 'webhooks.github.secret',
  GITLAB_WEBHOOK_TOKEN: 'webhooks.gitlab.token',
  TAMMA_WEBHOOK_BOT_USERNAME: 'webhooks.github.botUsername',
};
```

## Performance Considerations

1. **Fast Loading**: Configuration loading in <500ms
2. **Minimal Memory**: Efficient configuration representation
3. **Lazy Loading**: Load optional configurations only when needed
4. **Caching**: Cache parsed configurations to avoid re-parsing
5. **Async Operations**: Non-blocking file I/O operations

## Security Considerations

1. **Secrets Protection**: Never log or expose secrets
2. **Input Validation**: Validate all configuration values
3. **File Permissions**: Secure config file permissions (600)
4. **Environment Variables**: Use environment variables for sensitive data
5. **Secrets Management**: Integration with secure secret stores

## Monitoring and Observability

1. **Configuration Metrics**: Track configuration loading times
2. **Validation Errors**: Monitor configuration validation failures
3. **Hot Reload Events**: Track configuration reload events
4. **Secret Access**: Audit secret access patterns
5. **Configuration Drift**: Detect configuration changes

## Dependencies

### External Dependencies

```json
{
  "dependencies": {
    "zod": "^3.23.0",
    "yaml": "^2.4.0",
    "toml": "^3.0.0",
    "chokidar": "^4.0.0",
    "aws-sdk": "^2.1500.0"
  }
}
```

## Success Metrics

1. **Loading Performance**: <500ms configuration loading time
2. **Validation Accuracy**: 100% validation of required fields
3. **Error Clarity**: Clear, actionable error messages
4. **Hot Reload Reliability**: >99% successful hot reload operations
5. **Security**: Zero secret exposures in logs/errors

---

## ⚠️ MANDATORY: Before You Code

**ALL contributors MUST read and follow the comprehensive development process:**

📖 **[BEFORE_YOU_CODE.md](../../BEFORE_YOU_CODE.md)**

This mandatory guide includes:
- 7-Phase Development Workflow (Read → Research → Break Down → TDD → Quality Gates → Failure Handling)
- Knowledge Base Usage (.dev/ directory: spikes, bugs, findings, decisions)
- TRACE/DEBUG Logging Requirements for all functions
- Test-Driven Development (TDD) mandatory workflow
- 100% Test Coverage requirement
- Build Success enforcement
- Automatic retry and developer alert procedures

**Failure to follow this process will result in rework.**

---

**Technical Context Created:** 2025-10-29  
**Last Updated:** 2025-10-29  
**Next Story:** 1.5-8 - NPM Package Publishing

### References

- **🔴 MANDATORY PROCESS:** [BEFORE_YOU_CODE.md](../../BEFORE_YOU_CODE.md)
- **Knowledge Base:** [.dev/README.md](../../.dev/README.md) - Search spikes, bugs, findings, decisions
