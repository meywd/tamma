# Story 1.5-8: NPM Package Publishing

## ‚ö†Ô∏è MANDATORY: Before You Code

**ALL contributors MUST read and follow the comprehensive development process:**

üìñ **[BEFORE_YOU_CODE.md](../../BEFORE_YOU_CODE.md)**

This mandatory guide includes:
- 7-Phase Development Workflow (Read ‚Üí Research ‚Üí Break Down ‚Üí TDD ‚Üí Quality Gates ‚Üí Failure Handling)
- Knowledge Base Usage (.dev/ directory: spikes, bugs, findings, decisions)
- TRACE/DEBUG Logging Requirements for all functions
- Test-Driven Development (TDD) mandatory workflow
- 100% Test Coverage requirement
- Build Success enforcement
- Automatic retry and developer alert procedures

**Failure to follow this process will result in rework.**

## Context

Tamma needs to be published as npm packages to enable easy installation and distribution. This involves setting up automated publishing workflows, version management, and package distribution across multiple packages in the monorepo.

## Technical Specification

### 1. Package Publishing Strategy

#### 1.1 Multi-Package Publishing

```typescript
// packages/cli/package.json
{
  "name": "@tamma/cli",
  "version": "1.0.0",
  "description": "Tamma CLI - Autonomous development orchestration",
  "main": "dist/index.js",
  "bin": {
    "tamma": "dist/index.js"
  },
  "files": [
    "dist",
    "README.md",
    "LICENSE"
  ],
  "publishConfig": {
    "access": "public",
    "registry": "https://registry.npmjs.org/"
  }
}

// packages/orchestrator/package.json
{
  "name": "@tamma/orchestrator",
  "version": "1.0.0",
  "description": "Tamma orchestrator - Autonomous workflow engine",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "files": [
    "dist",
    "README.md",
    "LICENSE"
  ]
}
```

#### 1.2 Version Management Strategy

```yaml
# .github/workflows/release.yml
name: Release
on:
  push:
    tags:
      - 'v*'

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          registry-url: 'https://registry.npmjs.org'

      - name: Install pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 9

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build packages
        run: pnpm build

      - name: Publish packages
        run: pnpm publish -r --no-git-checks
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
```

### 2. Automated Version Bumping

#### 2.1 Changeset Configuration

```json
// .changeset/config.json
{
  "$schema": "https://unpkg.com/@changesets/config@2.3.1/schema.json",
  "changelog": "@changesets/cli/changelog",
  "commit": false,
  "fixed": [],
  "linked": [],
  "access": "public",
  "baseBranch": "main",
  "updateInternalDependencies": "patch",
  "ignore": []
}
```

#### 2.2 Version Bumping Workflow

```yaml
# .github/workflows/version.yml
name: Version
on:
  push:
    branches:
      - main

jobs:
  version:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          registry-url: 'https://registry.npmjs.org'

      - name: Install pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 9

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Create Release Pull Request or Publish
        id: changesets
        uses: changesets/action@v1
        with:
          publish: pnpm publish -r
          commit: 'chore: release packages'
          title: 'chore: release packages'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
```

### 3. Package Configuration

#### 3.1 Root Package Configuration

```json
// package.json
{
  "name": "@tamma/root",
  "private": true,
  "workspaces": ["packages/*"],
  "scripts": {
    "build": "pnpm -r build",
    "test": "pnpm -r test",
    "lint": "pnpm -r lint",
    "publish": "pnpm -r publish",
    "changeset": "changeset",
    "version-packages": "changeset version",
    "release": "pnpm build && changeset publish"
  },
  "devDependencies": {
    "@changesets/cli": "^2.27.1",
    "@typescript-eslint/eslint-plugin": "^6.0.0",
    "@typescript-eslint/parser": "^6.0.0",
    "eslint": "^8.0.0",
    "prettier": "^3.0.0",
    "typescript": "^5.7.0",
    "vitest": "^3.0.0"
  }
}
```

#### 3.2 Individual Package Scripts

```json
// packages/cli/package.json
{
  "scripts": {
    "build": "tsc && chmod +x dist/index.js",
    "dev": "tsc --watch",
    "test": "vitest run",
    "test:watch": "vitest",
    "lint": "eslint src --ext .ts",
    "format": "prettier --write src/**/*.ts"
  },
  "dependencies": {
    "@tamma/core": "workspace:*",
    "@tamma/shared": "workspace:*",
    "commander": "^11.0.0",
    "ink": "^5.0.0",
    "react": "^18.0.0"
  }
}
```

### 4. Distribution Configuration

#### 4.1 Package Registry Configuration

```typescript
// scripts/publish.ts
import { execSync } from 'child_process';
import { readFileSync } from 'fs';
import { join } from 'path';

interface PackageInfo {
  name: string;
  version: string;
  private?: boolean;
}

async function publishPackages() {
  const packagesDir = join(process.cwd(), 'packages');
  const packages = ['cli', 'orchestrator', 'workers', 'api', 'shared'];

  for (const pkg of packages) {
    const packageJsonPath = join(packagesDir, pkg, 'package.json');
    const packageJson: PackageInfo = JSON.parse(readFileSync(packageJsonPath, 'utf8'));

    if (packageJson.private) {
      console.log(`Skipping private package: ${packageJson.name}`);
      continue;
    }

    try {
      console.log(`Publishing ${packageJson.name}@${packageJson.version}...`);

      // Check if package already exists
      const checkCmd = `npm view ${packageJson.name} version`;
      try {
        const existingVersion = execSync(checkCmd, { encoding: 'utf8' }).trim();
        if (existingVersion === packageJson.version) {
          console.log(`Package ${packageJson.name}@${packageJson.version} already published`);
          continue;
        }
      } catch {
        // Package doesn't exist, continue with publish
      }

      // Publish package
      const publishCmd = `cd packages/${pkg} && npm publish --access public`;
      execSync(publishCmd, { stdio: 'inherit' });

      console.log(`‚úÖ Published ${packageJson.name}@${packageJson.version}`);
    } catch (error) {
      console.error(`‚ùå Failed to publish ${packageJson.name}:`, error);
      process.exit(1);
    }
  }
}

if (require.main === module) {
  publishPackages().catch(console.error);
}
```

#### 4.2 Registry Authentication

```bash
# .npmrc
@tamma:registry=https://registry.npmjs.org/
//registry.npmjs.org/:_authToken=${NPM_TOKEN}
```

### 5. Release Management

#### 5.1 Release Notes Generation

```typescript
// scripts/generate-release-notes.ts
import { execSync } from 'child_process';
import { readFileSync, writeFileSync } from 'fs';
import { join } from 'path';

interface ChangeSet {
  summary: string;
  releases: Array<{
    name: string;
    type: 'patch' | 'minor' | 'major';
    version: string;
    changes: string[];
  }>;
}

async function generateReleaseNotes() {
  const lastTag = execSync('git describe --tags --abbrev=0', { encoding: 'utf8' }).trim();
  const commits = execSync(`git log ${lastTag}..HEAD --oneline`, { encoding: 'utf8' })
    .split('\n')
    .filter((line) => line.trim());

  const changesetsDir = join(process.cwd(), '.changeset');
  const changesetFiles = execSync(`find ${changesetsDir} -name "*.md"`, { encoding: 'utf8' })
    .split('\n')
    .filter((file) => file.trim());

  const features: string[] = [];
  const fixes: string[] = [];
  const chores: string[] = [];

  for (const file of changesetFiles) {
    const content = readFileSync(file, 'utf8');
    const lines = content.split('\n');

    let currentSection = '';
    for (const line of lines) {
      if (line.startsWith('---')) {
        currentSection = '';
        continue;
      }

      if (line.includes('type:')) {
        const type = line.split(':')[1].trim();
        currentSection = type;
        continue;
      }

      if (line.trim() && currentSection) {
        const change = line.replace(/^-\s*/, '').trim();
        switch (currentSection) {
          case 'minor':
            features.push(change);
            break;
          case 'patch':
            fixes.push(change);
            break;
          case 'major':
            features.push(`**BREAKING:** ${change}`);
            break;
        }
      }
    }
  }

  const releaseNotes = `# Release ${process.env.RELEASE_VERSION || 'Latest'}

## üöÄ Features
${features.map((f) => `- ${f}`).join('\n') || '- No new features'}

## üêõ Fixes
${fixes.map((f) => `- ${f}`).join('\n') || '- No bug fixes'}

## üì¶ Packages
${execSync('pnpm -r exec npm pack --dry-run', { encoding: 'utf8' })
  .split('\n')
  .filter((line) => line.includes('npm notice'))
  .map((line) => line.replace('npm notice ', '- '))
  .join('\n')}

## üìà Stats
- Total commits: ${commits.length}
- Files changed: ${execSync(`git diff --name-only ${lastTag}..HEAD | wc -l`, { encoding: 'utf8' }).trim()}
- Lines added: ${execSync(`git diff --stat ${lastTag}..HEAD | tail -1`, { encoding: 'utf8' }).trim()}
`;

  writeFileSync('RELEASE_NOTES.md', releaseNotes);
  console.log('‚úÖ Release notes generated');
}

if (require.main === module) {
  generateReleaseNotes().catch(console.error);
}
```

### 6. Quality Gates

#### 6.1 Pre-Publish Validation

```typescript
// scripts/validate-packages.ts
import { execSync } from 'child_process';
import { readFileSync } from 'fs';
import { join } from 'path';

interface ValidationResult {
  package: string;
  valid: boolean;
  errors: string[];
}

async function validatePackages(): Promise<ValidationResult[]> {
  const packagesDir = join(process.cwd(), 'packages');
  const packages = ['cli', 'orchestrator', 'workers', 'api', 'shared'];
  const results: ValidationResult[] = [];

  for (const pkg of packages) {
    const errors: string[] = [];
    const packageJsonPath = join(packagesDir, pkg, 'package.json');
    const packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf8'));

    // Validate required fields
    const requiredFields = ['name', 'version', 'description', 'main', 'files'];
    for (const field of requiredFields) {
      if (!packageJson[field]) {
        errors.push(`Missing required field: ${field}`);
      }
    }

    // Validate version format
    if (!packageJson.version.match(/^\d+\.\d+\.\d+$/)) {
      errors.push('Invalid version format (should be x.y.z)');
    }

    // Validate dependencies
    if (packageJson.dependencies) {
      for (const [name, version] of Object.entries(packageJson.dependencies)) {
        if (typeof version !== 'string') {
          errors.push(`Invalid dependency version for ${name}`);
        }
      }
    }

    // Check if build exists
    try {
      execSync(`test -f packages/${pkg}/dist/index.js`, { stdio: 'ignore' });
    } catch {
      errors.push('Build output missing');
    }

    // Run tests
    try {
      execSync(`cd packages/${pkg} && npm test`, { stdio: 'ignore' });
    } catch {
      errors.push('Tests failed');
    }

    results.push({
      package: pkg,
      valid: errors.length === 0,
      errors,
    });
  }

  return results;
}

if (require.main === module) {
  validatePackages().then((results) => {
    const hasErrors = results.some((r) => !r.valid);

    if (hasErrors) {
      console.error('‚ùå Package validation failed:');
      results.forEach((result) => {
        if (!result.valid) {
          console.error(`\n${result.package}:`);
          result.errors.forEach((error) => console.error(`  - ${error}`));
        }
      });
      process.exit(1);
    } else {
      console.log('‚úÖ All packages validated successfully');
    }
  });
}
```

### 7. Distribution Channels

#### 7.1 Multiple Registry Support

```typescript
// scripts/publish-to-registries.ts
interface Registry {
  name: string;
  url: string;
  token: string;
}

const registries: Registry[] = [
  {
    name: 'npm',
    url: 'https://registry.npmjs.org/',
    token: process.env.NPM_TOKEN || '',
  },
  {
    name: 'github',
    url: 'https://npm.pkg.github.com/',
    token: process.env.GITHUB_TOKEN || '',
  },
];

async function publishToAllRegistries() {
  for (const registry of registries) {
    if (!registry.token) {
      console.log(`Skipping ${registry.name} (no token)`);
      continue;
    }

    console.log(`Publishing to ${registry.name}...`);

    try {
      execSync(`npm config set registry ${registry.url}`);
      execSync(
        `npm config set //${registry.url.replace('https://', '').replace('/', '_')}/:_authToken ${registry.token}`
      );

      execSync('pnpm publish -r --no-git-checks', { stdio: 'inherit' });

      console.log(`‚úÖ Published to ${registry.name}`);
    } catch (error) {
      console.error(`‚ùå Failed to publish to ${registry.name}:`, error);
    }
  }
}

if (require.main === module) {
  publishToAllRegistries().catch(console.error);
}
```

## Implementation Tasks

### Phase 1: Setup (Week 1)

1. **Configure Changesets**
   - Install and configure @changesets/cli
   - Set up changeset configuration
   - Create initial changeset files

2. **Package Configuration**
   - Update all package.json files with proper metadata
   - Configure publish settings and file lists
   - Set up workspace dependencies

### Phase 2: Automation (Week 2)

1. **GitHub Workflows**
   - Create version bumping workflow
   - Set up release workflow
   - Configure automated publishing

2. **Validation Scripts**
   - Implement pre-publish validation
   - Add package quality checks
   - Set up automated testing

### Phase 3: Distribution (Week 3)

1. **Multi-Registry Support**
   - Configure GitHub Packages registry
   - Set up npm registry publishing
   - Implement registry switching

2. **Release Management**
   - Implement release notes generation
   - Set up changelog automation
   - Configure version tagging

## Acceptance Criteria

### Functional Requirements

- [ ] All packages can be published to npm registry
- [ ] Automated version bumping with changesets
- [ ] Pre-publish validation prevents broken releases
- [ ] Release notes are automatically generated
- [ ] Multiple registry support (npm, GitHub Packages)

### Non-Functional Requirements

- [ ] Publishing process is fully automated
- [ ] Semantic versioning is enforced
- [ ] All packages pass validation before publishing
- [ ] Release process is auditable and reversible
- [ ] Documentation is updated with installation instructions

### Integration Requirements

- [ ] CI/CD pipeline integration
- [ ] GitHub Actions automation
- [ ] Package registry authentication
- [ ] Version tagging and releases
- [ ] Changelog generation

## Testing Strategy

### Unit Tests

- Package validation logic
- Version bumping scripts
- Registry configuration
- Release notes generation

### Integration Tests

- End-to-end publishing workflow
- Multi-registry publishing
- Authentication and permissions
- Package installation tests

### Manual Testing

- Manual package publishing verification
- Installation from registry testing
- Version compatibility testing
- Documentation verification

## Dependencies

### Internal Dependencies

- All Epic 1.5 stories (1.5-1 through 1.5-7)
- Package build system
- Monorepo structure

### External Dependencies

- npm registry access
- GitHub Packages
- Changesets CLI
- GitHub Actions

## Risks and Mitigations

### Technical Risks

- **Registry authentication failures**: Implement proper token management and validation
- **Version conflicts**: Use semantic versioning and automated conflict resolution
- **Package corruption**: Implement checksums and validation

### Operational Risks

- **Accidental releases**: Require manual approval for production releases
- **Registry downtime**: Support multiple registries for redundancy
- **Dependency issues**: Implement dependency validation and locking

## Success Metrics

### Publishing Metrics

- Time from commit to published package: < 30 minutes
- Publishing success rate: > 99%
- Automated publishing coverage: 100%

### Quality Metrics

- Package validation pass rate: 100%
- Test coverage before publishing: > 80%
- Documentation completeness: 100%

### Usage Metrics

- Package downloads (npm, GitHub Packages)
- Installation success rate
- User-reported issues with packages

## Rollout Plan

### Phase 1: Internal Testing

- Test publishing to internal registries
- Validate automation workflows
- Test package installation

### Phase 2: Public Beta

- Publish to npm as beta versions
- Gather user feedback
- Fix reported issues

### Phase 3: General Availability

- Publish stable versions
- Update documentation
- Promote usage

## Monitoring and Alerting

### Publishing Metrics

- Publishing success/failure rates
- Time to publish
- Registry response times

### Quality Metrics

- Package validation results
- Test coverage trends
- Dependency vulnerability scans

### Usage Metrics

- Download counts
- Installation success rates
- User feedback and issues

### References

- **üî¥ MANDATORY PROCESS:** [BEFORE_YOU_CODE.md](../../BEFORE_YOU_CODE.md)
- **Knowledge Base:** [.dev/README.md](../../.dev/README.md) - Search spikes, bugs, findings, decisions
