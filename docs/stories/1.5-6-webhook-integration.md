# Story 1.5-6: Webhook Integration

**Epic:** 1.5 - Deployment, Packaging & Operations  
**Status:** Ready for Development  
**Priority:** MVP Critical  
**Estimated Effort:** 4 days

## Overview

Implement GitHub and GitLab webhook processing with signature verification, event filtering, and task queue integration. Webhook integration enables Tamma to automatically respond to issue assignments, PR events, and comments, providing the foundation for autonomous development workflows triggered by external events.

## Technical Context

### ⚠️ Development Process Reminder

**Before implementing this story, ensure you have:**
1. ✅ Read [BEFORE_YOU_CODE.md](../../BEFORE_YOU_CODE.md)
2. ✅ Searched `.dev/` directory for related spikes, bugs, findings, and decisions
3. ✅ Reviewed relevant documentation in `docs/` directory
4. ✅ Checked existing code patterns for similar functionality
5. ✅ Planned TDD approach (Red-Green-Refactor cycle)


Webhook integration is critical for Tamma's self-maintenance capability. It allows Tamma to receive real-time events from Git platforms and automatically trigger autonomous development workflows. The implementation must securely verify webhook signatures, filter relevant events, transform payloads into standardized tasks, and enqueue them for processing by the service mode (Story 1.5-3).

The web server from Story 1.5-4 provides the HTTP endpoints, while this story implements the webhook processing logic that connects Git platform events to Tamma's task queue system.

## Acceptance Criteria

1. GitHub webhook signature verification (HMAC-SHA256)
2. GitLab webhook token verification
3. Webhook events enqueued to task queue within 200ms
4. Support for issue assignment, issue comment, PR review events
5. Configurable bot username for filtering relevant events
6. Webhook failure logging with error details
7. Rate limiting (100 requests/minute per IP)
8. Unit tests validate signature verification and event parsing
9. Integration tests validate end-to-end webhook flow (GitHub/GitLab → queue → processing)

## Implementation Details

### Webhook Package Structure

```
packages/
├── server/                  # @tamma/server - Service & Web launch wrapper
│   ├── src/
│   │   ├── webhooks/        # Webhook handlers
│   │   │   ├── github.ts    # GitHub webhook processing
│   │   │   ├── gitlab.ts   # GitLab webhook processing
│   │   │   ├── signature.ts # Signature verification
│   │   │   ├── transformer.ts # Payload transformation
│   │   │   ├── filter.ts    # Event filtering
│   │   │   └── index.ts
│   │   ├── web/             # Web server (from Story 1.5-4)
│   │   │   └── ...
│   │   ├── service/         # Service mode (from Story 1.5-3)
│   │   │   └── ...
│   │   ├── queue/           # Task queue implementations
│   │   │   └── ...
│   │   └── index.ts
│   ├── tests/
│   │   ├── webhooks/
│   │   │   ├── github.test.ts
│   │   │   ├── gitlab.test.ts
│   │   │   ├── signature.test.ts
│   │   │   └── integration/
│   │   └── ...
│   └── ...
```

### GitHub Webhook Handler

```typescript
// @tamma/server/src/webhooks/github.ts
import crypto from 'crypto';
import { ITaskQueue, TaskType, TaskPriority } from '../queue';
import { createLogger, ILogger } from '@tamma/observability';
import { WebhookConfig } from '@tamma/config';

export interface GitHubWebhookEvent {
  // Common fields
  action: string;
  sender: {
    login: string;
    id: number;
    type: string;
  };
  repository: {
    id: number;
    name: string;
    full_name: string;
    private: boolean;
    default_branch: string;
  };
  organization?: {
    login: string;
    id: number;
  };
  installation?: {
    id: number;
  };

  // Event-specific fields
  issue?: GitHubIssue;
  pull_request?: GitHubPullRequest;
  comment?: GitHubComment;
  assignee?: GitHubUser;
  label?: GitHubLabel;
}

export interface GitHubIssue {
  id: number;
  number: number;
  title: string;
  body: string | null;
  state: 'open' | 'closed';
  locked: boolean;
  assignees: GitHubUser[];
  labels: GitHubLabel[];
  milestone: GitHubMilestone | null;
  comments: number;
  created_at: string;
  updated_at: string;
  closed_at: string | null;
  author_association: string;
  user: GitHubUser;
}

export interface GitHubPullRequest {
  id: number;
  number: number;
  title: string;
  body: string | null;
  state: 'open' | 'closed';
  locked: boolean;
  head: GitHubPullRequestBranch;
  base: GitHubPullRequestBranch;
  merged: boolean;
  mergeable: boolean | null;
  merged_at: string | null;
  comments: number;
  review_comments: number;
  commits: number;
  additions: number;
  deletions: number;
  changed_files: number;
  user: GitHubUser;
  requested_reviewers: GitHubUser[];
}

export interface GitHubComment {
  id: number;
  body: string;
  user: GitHubUser;
  created_at: string;
  updated_at: string;
  author_association: string;
}

export interface GitHubUser {
  login: string;
  id: number;
  type: 'User' | 'Bot';
  site_admin: boolean;
}

export interface GitHubLabel {
  id: number;
  name: string;
  color: string;
  description: string | null;
}

export interface GitHubMilestone {
  id: number;
  number: number;
  title: string;
  description: string | null;
  state: 'open' | 'closed';
}

export interface GitHubPullRequestBranch {
  label: string;
  ref: string;
  sha: string;
  user: GitHubUser;
  repo: {
    id: number;
    name: string;
    full_name: string;
  };
}

export class GitHubWebhookHandler {
  private logger: ILogger;
  private config: WebhookConfig;
  private taskQueue: ITaskQueue;

  constructor(config: WebhookConfig, taskQueue: ITaskQueue) {
    this.config = config;
    this.taskQueue = taskQueue;
    this.logger = createLogger('github-webhook');
  }

  async handleWebhook(
    event: string,
    signature: string,
    payload: GitHubWebhookEvent,
    requestId: string
  ): Promise<{ status: string; processed: boolean }> {
    const startTime = Date.now();

    try {
      this.logger.info('GitHub webhook received', {
        requestId,
        event,
        action: payload.action,
        repository: payload.repository?.full_name,
        sender: payload.sender?.login,
      });

      // Verify signature
      if (!this.verifySignature(payload, signature)) {
        this.logger.warn('Invalid GitHub webhook signature', {
          requestId,
          event,
          repository: payload.repository?.full_name,
        });

        return { status: 'invalid_signature', processed: false };
      }

      // Process event based on type
      const processed = await this.processEvent(event, payload, requestId);

      const processingTime = Date.now() - startTime;
      this.logger.info('GitHub webhook processed', {
        requestId,
        event,
        processed,
        processingTime,
      });

      return { status: 'processed', processed };
    } catch (error) {
      const processingTime = Date.now() - startTime;
      this.logger.error('GitHub webhook processing failed', {
        requestId,
        event,
        error: error.message,
        stack: error.stack,
        processingTime,
      });

      return { status: 'error', processed: false };
    }
  }

  private verifySignature(payload: any, signature: string): boolean {
    if (!this.config.github?.secret) {
      this.logger.warn('GitHub webhook secret not configured');
      return false;
    }

    try {
      const expectedSignature =
        'sha256=' +
        crypto
          .createHmac('sha256', this.config.github.secret)
          .update(JSON.stringify(payload))
          .digest('hex');

      return crypto.timingSafeEqual(Buffer.from(signature), Buffer.from(expectedSignature));
    } catch (error) {
      this.logger.error('GitHub signature verification failed', { error });
      return false;
    }
  }

  private async processEvent(
    event: string,
    payload: GitHubWebhookEvent,
    requestId: string
  ): Promise<boolean> {
    switch (event) {
      case 'issues':
        return await this.handleIssuesEvent(payload, requestId);

      case 'issue_comment':
        return await this.handleIssueCommentEvent(payload, requestId);

      case 'pull_request':
        return await this.handlePullRequestEvent(payload, requestId);

      case 'pull_request_review':
        return await this.handlePullRequestReviewEvent(payload, requestId);

      default:
        this.logger.debug('Unhandled GitHub event', {
          requestId,
          event,
          action: payload.action,
        });
        return false;
    }
  }

  private async handleIssuesEvent(
    payload: GitHubWebhookEvent,
    requestId: string
  ): Promise<boolean> {
    const { action, issue, assignee, repository } = payload;

    // Only process assignment events
    if (action !== 'assigned') {
      this.logger.debug('Ignoring non-assignment issue event', {
        requestId,
        action,
        issueNumber: issue?.number,
      });
      return false;
    }

    // Check if assigned to our bot
    if (!this.isBotUser(assignee)) {
      this.logger.debug('Issue not assigned to bot', {
        requestId,
        assignee: assignee?.login,
        botUsername: this.config.github?.botUsername,
      });
      return false;
    }

    if (!issue) {
      this.logger.warn('Issue payload missing', { requestId });
      return false;
    }

    // Determine task priority based on issue properties
    const priority = this.determineIssuePriority(issue);

    // Create task payload
    const taskPayload = {
      type: TaskType.ISSUE_ASSIGNED,
      priority,
      payload: {
        repository: repository.full_name,
        issue: {
          number: issue.number,
          title: issue.title,
          body: issue.body,
          labels: issue.labels.map((label) => label.name),
          assignee: issue.assignees.map((user) => user.login),
          state: issue.state,
          createdAt: issue.created_at,
          updatedAt: issue.updated_at,
          user: issue.user.login,
        },
        sender: payload.sender.login,
        action: payload.action,
      },
    };

    // Enqueue task
    const task = await this.taskQueue.enqueue(taskPayload);

    this.logger.info('Issue assignment task created', {
      requestId,
      taskId: task.id,
      repository: repository.full_name,
      issueNumber: issue.number,
      priority,
    });

    return true;
  }

  private async handleIssueCommentEvent(
    payload: GitHubWebhookEvent,
    requestId: string
  ): Promise<boolean> {
    const { action, issue, comment, repository } = payload;

    // Only process new comments
    if (action !== 'created') {
      return false;
    }

    if (!comment || !issue) {
      this.logger.warn('Comment or issue payload missing', { requestId });
      return false;
    }

    // Check if comment mentions our bot
    const botMention = `@${this.config.github?.botUsername}`;
    if (!comment.body.toLowerCase().includes(botMention.toLowerCase())) {
      this.logger.debug('Comment does not mention bot', {
        requestId,
        commentId: comment.id,
        botUsername: this.config.github?.botUsername,
      });
      return false;
    }

    // Determine task priority
    const priority = this.determineCommentPriority(comment, issue);

    // Create task payload
    const taskPayload = {
      type: TaskType.ISSUE_COMMENT,
      priority,
      payload: {
        repository: repository.full_name,
        issue: {
          number: issue.number,
          title: issue.title,
          body: issue.body,
          labels: issue.labels.map((label) => label.name),
          state: issue.state,
        },
        comment: {
          id: comment.id,
          body: comment.body,
          author: comment.user.login,
          createdAt: comment.created_at,
          authorAssociation: comment.author_association,
        },
        sender: payload.sender.login,
        action: payload.action,
      },
    };

    // Enqueue task
    const task = await this.taskQueue.enqueue(taskPayload);

    this.logger.info('Issue comment task created', {
      requestId,
      taskId: task.id,
      repository: repository.full_name,
      issueNumber: issue.number,
      commentId: comment.id,
      priority,
    });

    return true;
  }

  private async handlePullRequestEvent(
    payload: GitHubWebhookEvent,
    requestId: string
  ): Promise<boolean> {
    const { action, pull_request, repository } = payload;

    // Process relevant PR events
    const relevantActions = ['opened', 'synchronize', 'ready_for_review', 'closed'];
    if (!relevantActions.includes(action)) {
      return false;
    }

    if (!pull_request) {
      this.logger.warn('Pull request payload missing', { requestId });
      return false;
    }

    // For PR events, we might want to trigger different workflows
    // For now, focus on review requests
    if (action === 'opened' && pull_request.requested_reviewers?.length > 0) {
      return await this.handlePRReviewRequest(payload, requestId);
    }

    this.logger.debug('PR event not processed', {
      requestId,
      action,
      prNumber: pull_request.number,
    });

    return false;
  }

  private async handlePullRequestReviewEvent(
    payload: GitHubWebhookEvent,
    requestId: string
  ): Promise<boolean> {
    const { action, pull_request, repository } = payload;

    // Process review submission
    if (action !== 'submitted') {
      return false;
    }

    if (!pull_request) {
      this.logger.warn('Pull request payload missing in review event', { requestId });
      return false;
    }

    // Create task for PR review processing
    const taskPayload = {
      type: TaskType.PR_REVIEW_REQUESTED,
      priority: TaskPriority.MEDIUM,
      payload: {
        repository: repository.full_name,
        pullRequest: {
          number: pull_request.number,
          title: pull_request.title,
          body: pull_request.body,
          state: pull_request.state,
          head: pull_request.head,
          base: pull_request.base,
          user: pull_request.user.login,
          merged: pull_request.merged,
          mergeable: pull_request.mergeable,
        },
        sender: payload.sender.login,
        action: payload.action,
      },
    };

    // Enqueue task
    const task = await this.taskQueue.enqueue(taskPayload);

    this.logger.info('PR review task created', {
      requestId,
      taskId: task.id,
      repository: repository.full_name,
      prNumber: pull_request.number,
      action,
    });

    return true;
  }

  private async handlePRReviewRequest(
    payload: GitHubWebhookEvent,
    requestId: string
  ): Promise<boolean> {
    const { pull_request, repository } = payload;

    if (!pull_request) {
      return false;
    }

    // Create task for PR review processing
    const taskPayload = {
      type: TaskType.PR_REVIEW_REQUESTED,
      priority: TaskPriority.HIGH,
      payload: {
        repository: repository.full_name,
        pullRequest: {
          number: pull_request.number,
          title: pull_request.title,
          body: pull_request.body,
          state: pull_request.state,
          head: pull_request.head,
          base: pull_request.base,
          user: pull_request.user.login,
          requested_reviewers: pull_request.requested_reviewers?.map((user) => user.login) || [],
        },
        sender: payload.sender.login,
        action: 'review_requested',
      },
    };

    // Enqueue task
    const task = await this.taskQueue.enqueue(taskPayload);

    this.logger.info('PR review request task created', {
      requestId,
      taskId: task.id,
      repository: repository.full_name,
      prNumber: pull_request.number,
    });

    return true;
  }

  private isBotUser(user?: GitHubUser): boolean {
    if (!user) return false;

    const botUsername = this.config.github?.botUsername;
    if (!botUsername) return false;

    return user.login === botUsername || user.type === 'Bot';
  }

  private determineIssuePriority(issue: GitHubIssue): TaskPriority {
    // Priority based on labels and other factors
    const labels = issue.labels.map((label) => label.name.toLowerCase());

    // Critical priority
    if (labels.includes('critical') || labels.includes('urgent')) {
      return TaskPriority.CRITICAL;
    }

    // High priority
    if (labels.includes('high') || labels.includes('bug')) {
      return TaskPriority.HIGH;
    }

    // Medium priority
    if (labels.includes('enhancement') || labels.includes('feature')) {
      return TaskPriority.MEDIUM;
    }

    // Default to low priority
    return TaskPriority.LOW;
  }

  private determineCommentPriority(comment: GitHubComment, issue: GitHubIssue): TaskPriority {
    const body = comment.body.toLowerCase();

    // High priority for urgent requests
    if (body.includes('urgent') || body.includes('asap')) {
      return TaskPriority.HIGH;
    }

    // Medium priority for explicit requests
    if (body.includes('please') || body.includes('help')) {
      return TaskPriority.MEDIUM;
    }

    // Default to low priority
    return TaskPriority.LOW;
  }
}
```

### GitLab Webhook Handler

```typescript
// @tamma/server/src/webhooks/gitlab.ts
import { ITaskQueue, TaskType, TaskPriority } from '../queue';
import { createLogger, ILogger } from '@tamma/observability';
import { WebhookConfig } from '@tamma/config';

export interface GitLabWebhookEvent {
  object_kind: string;
  user: GitLabUser;
  repository?: GitLabRepository;
  project?: GitLabProject;
  object_attributes: any;
  assignees?: GitLabUser[];
  labels?: GitLabLabel[];
  changes?: any;
}

export interface GitLabUser {
  id: number;
  name: string;
  username: string;
  email: string;
}

export interface GitLabRepository {
  name: string;
  url: string;
  description: string;
  homepage: string;
  git_http_url: string;
  git_ssh_url: string;
  visibility_level: number;
}

export interface GitLabProject {
  id: number;
  name: string;
  path_with_namespace: string;
  description: string;
  web_url: string;
  avatar_url: string;
  git_ssh_url: string;
  git_http_url: string;
  namespace: GitLabNamespace;
  default_branch: string;
  visibility: 'public' | 'internal' | 'private';
}

export interface GitLabNamespace {
  id: number;
  name: string;
  path: string;
  kind: string;
  full_path: string;
}

export interface GitLabLabel {
  id: number;
  title: string;
  color: string;
  project_id: number;
  created_at: string;
  updated_at: string;
  template: boolean;
  description: string;
  type: 'ProjectLabel' | 'GroupLabel';
}

export interface GitLabIssueAttributes {
  id: number;
  iid: number;
  title: string;
  description: string;
  state: 'opened' | 'closed';
  created_at: string;
  updated_at: string;
  closed_at: string | null;
  assignee_ids: number[];
  assignee_id: number | null;
  labels: GitLabLabel[];
  milestone: GitLabMilestone | null;
  author_id: number;
  updated_by_id: number | null;
  last_edited_at: string | null;
  last_edited_by_id: number | null;
  confidential: boolean;
  discussion_locked: boolean;
  due_date: string | null;
  weight: number | null;
  web_url: string;
  time_stats: {
    time_estimate: number;
    total_time_spent: number;
    human_time_estimate: string;
    human_total_time_spent: string;
  };
}

export interface GitLabMilestone {
  id: number;
  iid: number;
  project_id: number;
  title: string;
  description: string;
  state: 'active' | 'closed';
  created_at: string;
  updated_at: string;
  due_date: string | null;
  start_date: string | null;
}

export class GitLabWebhookHandler {
  private logger: ILogger;
  private config: WebhookConfig;
  private taskQueue: ITaskQueue;

  constructor(config: WebhookConfig, taskQueue: ITaskQueue) {
    this.config = config;
    this.taskQueue = taskQueue;
    this.logger = createLogger('gitlab-webhook');
  }

  async handleWebhook(
    event: string,
    token: string,
    payload: GitLabWebhookEvent,
    requestId: string
  ): Promise<{ status: string; processed: boolean }> {
    const startTime = Date.now();

    try {
      this.logger.info('GitLab webhook received', {
        requestId,
        event,
        objectKind: payload.object_kind,
        project: payload.project?.path_with_namespace,
        user: payload.user?.username,
      });

      // Verify token
      if (!this.verifyToken(token)) {
        this.logger.warn('Invalid GitLab webhook token', {
          requestId,
          event,
          project: payload.project?.path_with_namespace,
        });

        return { status: 'invalid_token', processed: false };
      }

      // Process event based on type
      const processed = await this.processEvent(event, payload, requestId);

      const processingTime = Date.now() - startTime;
      this.logger.info('GitLab webhook processed', {
        requestId,
        event,
        processed,
        processingTime,
      });

      return { status: 'processed', processed };
    } catch (error) {
      const processingTime = Date.now() - startTime;
      this.logger.error('GitLab webhook processing failed', {
        requestId,
        event,
        error: error.message,
        stack: error.stack,
        processingTime,
      });

      return { status: 'error', processed: false };
    }
  }

  private verifyToken(token: string): boolean {
    if (!this.config.gitlab?.token) {
      this.logger.warn('GitLab webhook token not configured');
      return false;
    }

    return token === this.config.gitlab.token;
  }

  private async processEvent(
    event: string,
    payload: GitLabWebhookEvent,
    requestId: string
  ): Promise<boolean> {
    switch (event) {
      case 'Issue Hook':
        return await this.handleIssueHook(payload, requestId);

      case 'Note Hook':
        return await this.handleNoteHook(payload, requestId);

      case 'Merge Request Hook':
        return await this.handleMergeRequestHook(payload, requestId);

      default:
        this.logger.debug('Unhandled GitLab event', {
          requestId,
          event,
          objectKind: payload.object_kind,
        });
        return false;
    }
  }

  private async handleIssueHook(payload: GitLabWebhookEvent, requestId: string): Promise<boolean> {
    const { object_attributes, assignees, project, user } = payload;

    if (!object_attributes || !project) {
      this.logger.warn('Issue hook missing required fields', { requestId });
      return false;
    }

    // Only process assignment updates
    if (object_attributes.action !== 'update') {
      return false;
    }

    // Check if our bot is in assignees
    const botAssigned = assignees?.some(
      (assignee) => assignee.username === this.config.gitlab?.botUsername
    );

    if (!botAssigned) {
      this.logger.debug('Issue not assigned to bot', {
        requestId,
        assignees: assignees?.map((a) => a.username),
        botUsername: this.config.gitlab?.botUsername,
      });
      return false;
    }

    // Determine task priority
    const priority = this.determineGitLabIssuePriority(object_attributes);

    // Create task payload
    const taskPayload = {
      type: TaskType.ISSUE_ASSIGNED,
      priority,
      payload: {
        repository: project.path_with_namespace,
        issue: {
          number: object_attributes.iid,
          title: object_attributes.title,
          body: object_attributes.description,
          labels: object_attributes.labels?.map((label) => label.title) || [],
          assignee: assignees?.map((user) => user.username) || [],
          state: object_attributes.state,
          createdAt: object_attributes.created_at,
          updatedAt: object_attributes.updated_at,
          user: user.username,
        },
        sender: user.username,
        action: 'assigned',
      },
    };

    // Enqueue task
    const task = await this.taskQueue.enqueue(taskPayload);

    this.logger.info('GitLab issue assignment task created', {
      requestId,
      taskId: task.id,
      repository: project.path_with_namespace,
      issueNumber: object_attributes.iid,
      priority,
    });

    return true;
  }

  private async handleNoteHook(payload: GitLabWebhookEvent, requestId: string): Promise<boolean> {
    const { object_attributes, project, user } = payload;

    if (!object_attributes || !project) {
      this.logger.warn('Note hook missing required fields', { requestId });
      return false;
    }

    // Only process new comments
    if (object_attributes.noteable_type !== 'Issue' || object_attributes.action !== 'create') {
      return false;
    }

    // Check if comment mentions our bot
    const botMention = `@${this.config.gitlab?.botUsername}`;
    if (!object_attributes.note.toLowerCase().includes(botMention.toLowerCase())) {
      this.logger.debug('Note does not mention bot', {
        requestId,
        noteId: object_attributes.id,
        botUsername: this.config.gitlab?.botUsername,
      });
      return false;
    }

    // Get issue details (would need to fetch from GitLab API)
    // For now, use available information
    const priority = this.determineGitLabNotePriority(object_attributes);

    // Create task payload
    const taskPayload = {
      type: TaskType.ISSUE_COMMENT,
      priority,
      payload: {
        repository: project.path_with_namespace,
        issue: {
          number: object_attributes.noteable_iid,
          // Note: We'd need to fetch full issue details from GitLab API
        },
        comment: {
          id: object_attributes.id,
          body: object_attributes.note,
          author: user.username,
          createdAt: object_attributes.created_at,
          authorAssociation: 'none', // GitLab doesn't have this concept
        },
        sender: user.username,
        action: 'created',
      },
    };

    // Enqueue task
    const task = await this.taskQueue.enqueue(taskPayload);

    this.logger.info('GitLab note task created', {
      requestId,
      taskId: task.id,
      repository: project.path_with_namespace,
      issueNumber: object_attributes.noteable_iid,
      noteId: object_attributes.id,
      priority,
    });

    return true;
  }

  private async handleMergeRequestHook(
    payload: GitLabWebhookEvent,
    requestId: string
  ): Promise<boolean> {
    const { object_attributes, project, user } = payload;

    if (!object_attributes || !project) {
      this.logger.warn('Merge request hook missing required fields', { requestId });
      return false;
    }

    // Process relevant MR events
    const relevantActions = ['open', 'update', 'merge', 'close'];
    if (!relevantActions.includes(object_attributes.action)) {
      return false;
    }

    // For MR events, focus on review requests
    if (object_attributes.action === 'open') {
      return await this.handleMRReviewRequest(payload, requestId);
    }

    this.logger.debug('MR event not processed', {
      requestId,
      action: object_attributes.action,
      mrNumber: object_attributes.iid,
    });

    return false;
  }

  private async handleMRReviewRequest(
    payload: GitLabWebhookEvent,
    requestId: string
  ): Promise<boolean> {
    const { object_attributes, project, user } = payload;

    if (!object_attributes || !project) {
      return false;
    }

    // Create task for MR review processing
    const taskPayload = {
      type: TaskType.PR_REVIEW_REQUESTED,
      priority: TaskPriority.HIGH,
      payload: {
        repository: project.path_with_namespace,
        pullRequest: {
          number: object_attributes.iid,
          title: object_attributes.title,
          body: object_attributes.description,
          state: object_attributes.state,
          head: {
            ref: object_attributes.source_branch,
            sha: object_attributes.source?.commit?.id,
          },
          base: {
            ref: object_attributes.target_branch,
            sha: object_attributes.target?.commit?.id,
          },
          user: user.username,
          mergeable: object_attributes.merge_status === 'can_be_merged',
        },
        sender: user.username,
        action: 'review_requested',
      },
    };

    // Enqueue task
    const task = await this.taskQueue.enqueue(taskPayload);

    this.logger.info('GitLab MR review request task created', {
      requestId,
      taskId: task.id,
      repository: project.path_with_namespace,
      mrNumber: object_attributes.iid,
    });

    return true;
  }

  private determineGitLabIssuePriority(attributes: GitLabIssueAttributes): TaskPriority {
    const labels = attributes.labels?.map((label) => label.title.toLowerCase()) || [];

    // Critical priority
    if (labels.includes('critical') || labels.includes('urgent')) {
      return TaskPriority.CRITICAL;
    }

    // High priority
    if (labels.includes('high') || labels.includes('bug')) {
      return TaskPriority.HIGH;
    }

    // Medium priority
    if (labels.includes('enhancement') || labels.includes('feature')) {
      return TaskPriority.MEDIUM;
    }

    // Default to low priority
    return TaskPriority.LOW;
  }

  private determineGitLabNotePriority(attributes: any): TaskPriority {
    const note = attributes.note.toLowerCase();

    // High priority for urgent requests
    if (note.includes('urgent') || note.includes('asap')) {
      return TaskPriority.HIGH;
    }

    // Medium priority for explicit requests
    if (note.includes('please') || note.includes('help')) {
      return TaskPriority.MEDIUM;
    }

    // Default to low priority
    return TaskPriority.LOW;
  }
}
```

### Signature Verification

```typescript
// @tamma/server/src/webhooks/signature.ts
import crypto from 'crypto';
import { createLogger, ILogger } from '@tamma/observability';

export class WebhookSignatureVerifier {
  private logger: ILogger;

  constructor() {
    this.logger = createLogger('webhook-signature');
  }

  verifyGitHubSignature(payload: any, signature: string, secret: string): boolean {
    try {
      if (!signature || !secret) {
        this.logger.warn('Missing signature or secret for GitHub webhook');
        return false;
      }

      // Extract the signature algorithm and hash
      const [algorithm, hash] = signature.split('=');

      if (algorithm !== 'sha256') {
        this.logger.warn('Unsupported signature algorithm', { algorithm });
        return false;
      }

      // Calculate expected signature
      const expectedSignature = crypto
        .createHmac('sha256', secret)
        .update(JSON.stringify(payload))
        .digest('hex');

      // Use timing-safe comparison to prevent timing attacks
      return crypto.timingSafeEqual(
        Buffer.from(hash, 'hex'),
        Buffer.from(expectedSignature, 'hex')
      );
    } catch (error) {
      this.logger.error('GitHub signature verification error', { error });
      return false;
    }
  }

  verifyGitLabToken(token: string, expectedToken: string): boolean {
    try {
      if (!token || !expectedToken) {
        this.logger.warn('Missing token for GitLab webhook');
        return false;
      }

      return token === expectedToken;
    } catch (error) {
      this.logger.error('GitLab token verification error', { error });
      return false;
    }
  }

  generateGitHubSignature(payload: any, secret: string): string {
    const hash = crypto.createHmac('sha256', secret).update(JSON.stringify(payload)).digest('hex');

    return `sha256=${hash}`;
  }
}
```

### Webhook Integration with Web Server

```typescript
// @tamma/server/src/web/server.ts (updated webhook routes)

import { GitHubWebhookHandler } from '../webhooks/github';
import { GitLabWebhookHandler } from '../webhooks/gitlab';
import { WebhookSignatureVerifier } from '../webhooks/signature';

export class TammaWebServer {
  private githubHandler: GitHubWebhookHandler;
  private gitlabHandler: GitLabWebhookHandler;
  private signatureVerifier: WebhookSignatureVerifier;

  constructor(config: WebServerConfig, taskQueue: ITaskQueue, service?: TammaService) {
    // ... existing constructor code

    this.signatureVerifier = new WebhookSignatureVerifier();
    this.githubHandler = new GitHubWebhookHandler(config.webhooks, taskQueue);
    this.gitlabHandler = new GitLabWebhookHandler(config.webhooks, taskQueue);
  }

  private registerWebhookRoutes(fastify: FastifyInstance): void {
    // GitHub webhook endpoint
    fastify.post(
      '/webhooks/github',
      {
        config: {
          rateLimit: { max: 300, timeWindow: '1m' }, // Higher limit for webhooks
        },
      },
      async (request, reply) => {
        const requestId = this.generateRequestId();
        const signature = request.headers['x-hub-signature-256'] as string;
        const event = request.headers['x-github-event'] as string;
        const payload = request.body;

        try {
          // Verify signature
          if (
            !this.signatureVerifier.verifyGitHubSignature(
              payload,
              signature,
              this.config.webhooks?.github?.secret || ''
            )
          ) {
            this.metrics.webhookEventsFailed++;
            return reply.status(401).send({
              error: 'Invalid signature',
              requestId,
            });
          }

          this.metrics.webhookEventsReceived++;

          // Process webhook
          const result = await this.githubHandler.handleWebhook(
            event,
            signature,
            payload,
            requestId
          );

          if (result.processed) {
            this.metrics.webhookEventsProcessed++;
          }

          return {
            status: result.status,
            requestId,
            processed: result.processed,
          };
        } catch (error) {
          this.metrics.webhookEventsFailed++;
          this.logger.error('GitHub webhook processing failed', {
            requestId,
            error: error.message,
            event,
          });

          return reply.status(500).send({
            error: 'Webhook processing failed',
            requestId,
          });
        }
      }
    );

    // GitLab webhook endpoint
    fastify.post(
      '/webhooks/gitlab',
      {
        config: {
          rateLimit: { max: 300, timeWindow: '1m' },
        },
      },
      async (request, reply) => {
        const requestId = this.generateRequestId();
        const token = request.headers['x-gitlab-token'] as string;
        const event = request.headers['x-gitlab-event'] as string;
        const payload = request.body;

        try {
          // Verify token
          if (
            !this.signatureVerifier.verifyGitLabToken(
              token,
              this.config.webhooks?.gitlab?.token || ''
            )
          ) {
            this.metrics.webhookEventsFailed++;
            return reply.status(401).send({
              error: 'Invalid token',
              requestId,
            });
          }

          this.metrics.webhookEventsReceived++;

          // Process webhook
          const result = await this.gitlabHandler.handleWebhook(event, token, payload, requestId);

          if (result.processed) {
            this.metrics.webhookEventsProcessed++;
          }

          return {
            status: result.status,
            requestId,
            processed: result.processed,
          };
        } catch (error) {
          this.metrics.webhookEventsFailed++;
          this.logger.error('GitLab webhook processing failed', {
            requestId,
            error: error.message,
            event,
          });

          return reply.status(500).send({
            error: 'Webhook processing failed',
            requestId,
          });
        }
      }
    );
  }

  private generateRequestId(): string {
    return `webhook-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
}
```

## Testing Strategy

### Unit Tests

```typescript
// @tamma/server/tests/webhooks/github.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { GitHubWebhookHandler } from '../../../src/webhooks/github';
import { MemoryTaskQueue } from '../../../src/queue/memory-queue';

describe('GitHubWebhookHandler', () => {
  let handler: GitHubWebhookHandler;
  let mockQueue: any;
  let config: any;

  beforeEach(() => {
    mockQueue = new MemoryTaskQueue({});
    vi.spyOn(mockQueue, 'enqueue');

    config = {
      github: {
        secret: 'test-secret',
        botUsername: 'tamma-bot',
      },
    };

    handler = new GitHubWebhookHandler(config, mockQueue);
  });

  describe('signature verification', () => {
    it('should verify valid GitHub signature', () => {
      const payload = { test: 'data' };
      const signature = handler.generateGitHubSignature(payload, 'test-secret');

      const result = handler.verifySignature(payload, signature);
      expect(result).toBe(true);
    });

    it('should reject invalid GitHub signature', () => {
      const payload = { test: 'data' };
      const signature = 'sha256=invalid';

      const result = handler.verifySignature(payload, signature);
      expect(result).toBe(false);
    });

    it('should reject when secret is not configured', () => {
      const handlerNoSecret = new GitHubWebhookHandler({}, mockQueue);
      const payload = { test: 'data' };
      const signature = 'sha256=valid';

      const result = handlerNoSecret.verifySignature(payload, signature);
      expect(result).toBe(false);
    });
  });

  describe('issue assignment events', () => {
    it('should process issue assignment to bot', async () => {
      const payload = {
        action: 'assigned',
        issue: {
          number: 123,
          title: 'Test Issue',
          body: 'Test description',
          labels: [{ name: 'bug' }],
          assignees: [{ login: 'tamma-bot', type: 'User' }],
          state: 'open',
          created_at: '2023-01-01T00:00:00Z',
          updated_at: '2023-01-01T00:00:00Z',
          user: { login: 'testuser', type: 'User' },
        },
        assignee: { login: 'tamma-bot', type: 'User' },
        repository: {
          full_name: 'test/repo',
        },
        sender: { login: 'testuser' },
      };

      const result = await handler.handleWebhook('issues', 'valid-signature', payload, 'test-id');

      expect(result.processed).toBe(true);
      expect(mockQueue.enqueue).toHaveBeenCalledWith({
        type: 'issue_assigned',
        priority: expect.any(Number),
        payload: expect.objectContaining({
          repository: 'test/repo',
          issue: expect.objectContaining({
            number: 123,
            title: 'Test Issue',
          }),
        }),
      });
    });

    it('should ignore issue assignment to non-bot', async () => {
      const payload = {
        action: 'assigned',
        issue: {
          number: 123,
          assignees: [{ login: 'otheruser', type: 'User' }],
        },
        assignee: { login: 'otheruser', type: 'User' },
        repository: {
          full_name: 'test/repo',
        },
      };

      const result = await handler.handleWebhook('issues', 'valid-signature', payload, 'test-id');

      expect(result.processed).toBe(false);
      expect(mockQueue.enqueue).not.toHaveBeenCalled();
    });

    it('should ignore non-assignment issue events', async () => {
      const payload = {
        action: 'opened',
        issue: {
          number: 123,
          assignees: [{ login: 'tamma-bot', type: 'User' }],
        },
        repository: {
          full_name: 'test/repo',
        },
      };

      const result = await handler.handleWebhook('issues', 'valid-signature', payload, 'test-id');

      expect(result.processed).toBe(false);
      expect(mockQueue.enqueue).not.toHaveBeenCalled();
    });
  });

  describe('issue comment events', () => {
    it('should process comment mentioning bot', async () => {
      const payload = {
        action: 'created',
        issue: {
          number: 123,
          title: 'Test Issue',
          labels: [],
          state: 'open',
        },
        comment: {
          id: 456,
          body: '@tamma-bot please help with this issue',
          user: { login: 'testuser' },
          created_at: '2023-01-01T00:00:00Z',
          author_association: 'NONE',
        },
        repository: {
          full_name: 'test/repo',
        },
      };

      const result = await handler.handleWebhook(
        'issue_comment',
        'valid-signature',
        payload,
        'test-id'
      );

      expect(result.processed).toBe(true);
      expect(mockQueue.enqueue).toHaveBeenCalledWith({
        type: 'issue_comment',
        priority: expect.any(Number),
        payload: expect.objectContaining({
          repository: 'test/repo',
          issue: expect.objectContaining({
            number: 123,
          }),
          comment: expect.objectContaining({
            body: '@tamma-bot please help with this issue',
          }),
        }),
      });
    });

    it('should ignore comment not mentioning bot', async () => {
      const payload = {
        action: 'created',
        issue: {
          number: 123,
        },
        comment: {
          body: 'This is a regular comment',
          user: { login: 'testuser' },
        },
        repository: {
          full_name: 'test/repo',
        },
      };

      const result = await handler.handleWebhook(
        'issue_comment',
        'valid-signature',
        payload,
        'test-id'
      );

      expect(result.processed).toBe(false);
      expect(mockQueue.enqueue).not.toHaveBeenCalled();
    });
  });

  describe('priority determination', () => {
    it('should assign critical priority for critical labels', async () => {
      const payload = {
        action: 'assigned',
        issue: {
          number: 123,
          labels: [{ name: 'critical' }],
          assignees: [{ login: 'tamma-bot', type: 'User' }],
        },
        assignee: { login: 'tamma-bot', type: 'User' },
        repository: { full_name: 'test/repo' },
      };

      await handler.handleWebhook('issues', 'valid-signature', payload, 'test-id');

      expect(mockQueue.enqueue).toHaveBeenCalledWith({
        type: 'issue_assigned',
        priority: 3, // CRITICAL
        payload: expect.any(Object),
      });
    });

    it('should assign high priority for bug labels', async () => {
      const payload = {
        action: 'assigned',
        issue: {
          number: 123,
          labels: [{ name: 'bug' }],
          assignees: [{ login: 'tamma-bot', type: 'User' }],
        },
        assignee: { login: 'tamma-bot', type: 'User' },
        repository: { full_name: 'test/repo' },
      };

      await handler.handleWebhook('issues', 'valid-signature', payload, 'test-id');

      expect(mockQueue.enqueue).toHaveBeenCalledWith({
        type: 'issue_assigned',
        priority: 2, // HIGH
        payload: expect.any(Object),
      });
    });
  });
});
```

### Integration Tests

```typescript
// @tamma/server/tests/webhooks/integration/github-webhook.test.ts
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { TammaWebServer } from '../../../src/web/server';
import { MemoryTaskQueue } from '../../../src/queue/memory-queue';
import { loadConfig } from '@tamma/config';

describe('GitHub Webhook Integration Tests', () => {
  let server: TammaWebServer;
  let queue: MemoryTaskQueue;
  let baseUrl: string;
  let config: any;

  beforeAll(async () => {
    // Load test configuration
    config = await loadConfig('./test-config.yaml');
    config.mode = 'web';
    config.web.port = 0; // Random port for testing
    config.web.webhooks = {
      github: {
        secret: 'test-webhook-secret',
        botUsername: 'tamma-bot',
      },
    };

    queue = new MemoryTaskQueue({});
    server = new TammaWebServer(config.web, queue);
    await server.start();

    const address = server.fastify.server.address() as any;
    baseUrl = `http://127.0.0.1:${address.port}`;
  });

  afterAll(async () => {
    if (server) {
      await server.stop();
    }
  });

  describe('GitHub webhook endpoint', () => {
    it('should accept valid GitHub webhook', async () => {
      const payload = {
        action: 'assigned',
        issue: {
          number: 123,
          title: 'Test Issue',
          body: 'Test description',
          labels: [{ name: 'bug' }],
          assignees: [{ login: 'tamma-bot', type: 'User' }],
          state: 'open',
          created_at: '2023-01-01T00:00:00Z',
          updated_at: '2023-01-01T00:00:00Z',
          user: { login: 'testuser', type: 'User' },
        },
        assignee: { login: 'tamma-bot', type: 'User' },
        repository: {
          full_name: 'test/repo',
        },
        sender: { login: 'testuser' },
      };

      // Generate signature
      const crypto = require('crypto');
      const signature =
        'sha256=' +
        crypto
          .createHmac('sha256', 'test-webhook-secret')
          .update(JSON.stringify(payload))
          .digest('hex');

      const response = await fetch(`${baseUrl}/webhooks/github`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-GitHub-Event': 'issues',
          'X-Hub-Signature-256': signature,
        },
        body: JSON.stringify(payload),
      });

      expect(response.status).toBe(200);
      const data = await response.json();
      expect(data.status).toBe('processed');
      expect(data.processed).toBe(true);

      // Verify task was created
      const tasks = await queue.list();
      expect(tasks).toHaveLength(1);
      expect(tasks[0].type).toBe('issue_assigned');
      expect(tasks[0].payload.repository).toBe('test/repo');
      expect(tasks[0].payload.issue.number).toBe(123);
    });

    it('should reject webhook with invalid signature', async () => {
      const payload = { test: 'data' };

      const response = await fetch(`${baseUrl}/webhooks/github`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-GitHub-Event': 'issues',
          'X-Hub-Signature-256': 'sha256=invalid',
        },
        body: JSON.stringify(payload),
      });

      expect(response.status).toBe(401);
      const data = await response.json();
      expect(data.error).toBe('Invalid signature');
    });

    it('should handle webhook processing errors gracefully', async () => {
      const payload = {
        action: 'assigned',
        issue: null, // Invalid payload
        repository: {
          full_name: 'test/repo',
        },
      };

      const crypto = require('crypto');
      const signature =
        'sha256=' +
        crypto
          .createHmac('sha256', 'test-webhook-secret')
          .update(JSON.stringify(payload))
          .digest('hex');

      const response = await fetch(`${baseUrl}/webhooks/github`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-GitHub-Event': 'issues',
          'X-Hub-Signature-256': signature,
        },
        body: JSON.stringify(payload),
      });

      expect(response.status).toBe(200);
      const data = await response.json();
      expect(data.status).toBe('error');
      expect(data.processed).toBe(false);
    });
  });
});
```

## Configuration

### Webhook Configuration Schema

```typescript
// @tamma/config/src/schemas/webhook.schema.ts
export const WebhookConfigSchema = z.object({
  github: z
    .object({
      enabled: z.boolean().default(true),
      secret: z.string().min(1),
      botUsername: z.string().min(1),
    })
    .optional(),

  gitlab: z
    .object({
      enabled: z.boolean().default(false),
      token: z.string().min(1),
      botUsername: z.string().min(1),
    })
    .optional(),

  // Event filtering
  eventFilters: z
    .object({
      allowedRepositories: z.array(z.string()).optional(),
      blockedRepositories: z.array(z.string()).optional(),
      allowedUsers: z.array(z.string()).optional(),
      blockedUsers: z.array(z.string()).optional(),
      requireBotMention: z.boolean().default(true),
    })
    .default({}),

  // Processing options
  processing: z
    .object({
      maxPayloadSize: z.number().min(1024).max(10485760).default(1048576), // 1MB
      timeoutMs: z.number().min(1000).max(30000).default(10000),
      retryAttempts: z.number().min(0).max(5).default(3),
    })
    .default({}),
});

export type WebhookConfig = z.infer<typeof WebhookConfigSchema>;
```

## Performance Considerations

1. **Fast Processing**: Webhook events processed within 200ms
2. **Async Enqueuing**: Non-blocking task queue operations
3. **Memory Efficiency**: Minimal memory footprint per webhook
4. **Rate Limiting**: Prevent abuse and ensure fair usage
5. **Connection Pooling**: Efficient HTTP client usage

## Security Considerations

1. **Signature Verification**: HMAC-SHA256 for GitHub, token for GitLab
2. **Input Validation**: Validate all webhook payloads
3. **Rate Limiting**: Prevent DoS attacks
4. **Secret Management**: Secure storage of webhook secrets
5. **Audit Logging**: Complete audit trail of webhook processing

## Monitoring and Observability

1. **Webhook Metrics**: Events received, processed, failed
2. **Processing Time**: Track webhook processing latency
3. **Error Tracking**: Detailed error logging and alerting
4. **Queue Depth**: Monitor task queue backlog
5. **Signature Failures**: Track authentication failures

## Dependencies

### Internal Dependencies

- `@tamma/queue` - Task queue integration
- `@tamma/config` - Configuration management
- `@tamma/observability` - Logging and metrics

### External Dependencies

- `crypto` - Node.js built-in cryptographic functions
- No additional external dependencies required

## Success Metrics

1. **Processing Speed**: <200ms average webhook processing time
2. **Reliability**: >99% webhook processing success rate
3. **Security**: Zero unauthorized webhook processing
4. **Throughput**: Support for 100+ webhooks/minute
5. **Error Recovery**: Graceful handling of malformed payloads

---

## ⚠️ MANDATORY: Before You Code

**ALL contributors MUST read and follow the comprehensive development process:**

📖 **[BEFORE_YOU_CODE.md](../../BEFORE_YOU_CODE.md)**

This mandatory guide includes:
- 7-Phase Development Workflow (Read → Research → Break Down → TDD → Quality Gates → Failure Handling)
- Knowledge Base Usage (.dev/ directory: spikes, bugs, findings, decisions)
- TRACE/DEBUG Logging Requirements for all functions
- Test-Driven Development (TDD) mandatory workflow
- 100% Test Coverage requirement
- Build Success enforcement
- Automatic retry and developer alert procedures

**Failure to follow this process will result in rework.**

---

**Technical Context Created:** 2025-10-29  
**Last Updated:** 2025-10-29  
**Next Story:** 1.5-7 - System Configuration Management

### References

- **🔴 MANDATORY PROCESS:** [BEFORE_YOU_CODE.md](../../BEFORE_YOU_CODE.md)
- **Knowledge Base:** [.dev/README.md](../../.dev/README.md) - Search spikes, bugs, findings, decisions
