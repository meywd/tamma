# Story 1.5-1: Core Engine Separation

**Epic:** 1.5 - Deployment, Packaging & Operations  
**Status:** Ready for Development  
**Priority:** MVP Critical  
**Estimated Effort:** 5 days

## Overview

Extract the autonomous development loop logic from CLI-specific code into a reusable `@tamma/core` package that can be used by all deployment modes (CLI, service, web, worker). This separation establishes the modular architecture where the core engine contains the business logic while launch wrappers provide environment-specific initialization.

## Technical Context

### âš ï¸ Development Process Reminder

**Before implementing this story, ensure you have:**
1. âœ… Read [BEFORE_YOU_CODE.md](../../BEFORE_YOU_CODE.md)
2. âœ… Searched `.dev/` directory for related spikes, bugs, findings, and decisions
3. âœ… Reviewed relevant documentation in `docs/` directory
4. âœ… Checked existing code patterns for similar functionality
5. âœ… Planned TDD approach (Red-Green-Refactor cycle)


This story implements the core engine separation architecture defined in Epic 1.5 technical specification. The `@tamma/core` package will contain the `TammaEngine` class with the complete autonomous development loop implementation, while launch wrappers (`@tamma/cli`, `@tamma/server`) will use this core package without code duplication.

The core engine must be completely independent of CLI-specific or server-specific dependencies, ensuring consistent behavior across all deployment modes through a standardized `LaunchContext` interface.

## Acceptance Criteria

1. `@tamma/core` package exports `TammaEngine` class with complete autonomous loop implementation
2. Launch wrapper packages (`@tamma/cli`, `@tamma/server`) use core package without code duplication
3. All deployment modes (CLI, service, web, worker) use same core engine logic
4. Configuration passed to core engine through standardized `LaunchContext` interface
5. Core engine has no dependencies on CLI-specific or server-specific packages
6. Unit tests validate core engine isolation and behavior consistency
7. Integration tests validate all deployment modes execute same workflow with same results

## Implementation Details

### Core Engine Interface

```typescript
// @tamma/core/src/engine.ts
export class TammaEngine {
  private aiProvider: IAIProvider;
  private gitPlatform: IGitPlatform;
  private config: TammaConfig;
  private logger: ILogger;
  private state: EngineState;

  constructor(config: TammaConfig, logger: ILogger) {
    this.config = config;
    this.logger = logger;
    this.state = EngineState.IDLE;
  }

  // Lifecycle management
  async initialize(): Promise<void> {
    await this.aiProvider.initialize(this.config.aiProvider);
    await this.gitPlatform.initialize(this.config.gitPlatform);
    this.state = EngineState.READY;
  }

  async dispose(): Promise<void> {
    await this.aiProvider.dispose();
    this.state = EngineState.DISPOSED;
  }

  // Core autonomous loop methods
  async selectIssue(filters: IssueFilters): Promise<Issue | null>;
  async analyzeIssue(issue: Issue): Promise<IssueAnalysis>;
  async generatePlan(analysis: IssueAnalysis): Promise<DevelopmentPlan>;
  async createBranch(plan: DevelopmentPlan): Promise<Branch>;
  async implementCode(plan: DevelopmentPlan): Promise<CodeChanges>;
  async runTests(changes: CodeChanges): Promise<TestResults>;
  async createPullRequest(changes: CodeChanges): Promise<PullRequest>;
  async monitorPR(pr: PullRequest): Promise<PRStatus>;
  async mergePR(pr: PullRequest): Promise<MergeResult>;

  // State management
  getState(): EngineState;
  pauseExecution(): Promise<void>;
  resumeExecution(): Promise<void>;
}

// Launch wrapper interface for different modes
export interface LaunchContext {
  mode: 'cli' | 'service' | 'web' | 'worker';
  config: TammaConfig;
  logger: ILogger;
}

export async function createEngine(context: LaunchContext): Promise<TammaEngine> {
  const config = await loadConfig(context.config);
  const logger = createLogger(context.mode, config.logLevel);
  return new TammaEngine(config, logger);
}
```

### Package Structure

```
packages/
â”œâ”€â”€ core/                    # @tamma/core - Core engine logic
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ engine.ts        # TammaEngine class
â”‚   â”‚   â”œâ”€â”€ workflow/        # Workflow step implementations
â”‚   â”‚   â”‚   â”œâ”€â”€ issue-selection.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ issue-analysis.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ plan-generation.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ code-implementation.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ test-execution.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ pr-management.ts
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ state/           # State management
â”‚   â”‚   â”‚   â”œâ”€â”€ engine-state.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ workflow-state.ts
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ types/           # Core types
â”‚   â”‚   â”‚   â”œâ”€â”€ engine.types.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ workflow.types.ts
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ errors/          # Core error classes
â”‚   â”‚   â”‚   â”œâ”€â”€ engine-error.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ workflow-error.ts
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â””â”€â”€ index.ts         # Public API exports
â”‚   â”œâ”€â”€ tests/
â”‚   â”‚   â”œâ”€â”€ engine.test.ts
â”‚   â”‚   â”œâ”€â”€ workflow/
â”‚   â”‚   â””â”€â”€ integration/
â”‚   â”œâ”€â”€ package.json
â”‚   â””â”€â”€ tsconfig.json
```

### Dependencies

**@tamma/core package.json:**

```json
{
  "name": "@tamma/core",
  "version": "1.0.0",
  "description": "Tamma core engine - autonomous development loop",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "test": "vitest",
    "test:coverage": "vitest --coverage"
  },
  "dependencies": {
    "@tamma/shared": "workspace:*",
    "@tamma/providers": "workspace:*",
    "@tamma/platforms": "workspace:*",
    "pino": "^9.0.0"
  },
  "devDependencies": {
    "@types/node": "^22.0.0",
    "typescript": "^5.7.0",
    "vitest": "^2.0.0"
  }
}
```

### Workflow Implementation

```typescript
// @tamma/core/src/workflow/issue-selection.ts
export class IssueSelectionWorkflow {
  constructor(
    private gitPlatform: IGitPlatform,
    private logger: ILogger
  ) {}

  async selectIssue(filters: IssueFilters): Promise<Issue | null> {
    this.logger.info('Selecting issue', { filters });

    try {
      const issues = await this.gitPlatform.listIssues(filters);

      if (issues.length === 0) {
        this.logger.info('No issues found matching filters');
        return null;
      }

      // Apply additional filtering logic
      const filteredIssues = this.applyFilters(issues, filters);

      if (filteredIssues.length === 0) {
        this.logger.info('No issues passed additional filtering');
        return null;
      }

      // Select best issue based on priority and complexity
      const selectedIssue = this.selectBestIssue(filteredIssues);

      this.logger.info('Issue selected', {
        issueNumber: selectedIssue.number,
        title: selectedIssue.title,
      });

      return selectedIssue;
    } catch (error) {
      this.logger.error('Failed to select issue', { error, filters });
      throw new EngineError('ISSUE_SELECTION_FAILED', error.message);
    }
  }

  private applyFilters(issues: Issue[], filters: IssueFilters): Issue[] {
    return issues.filter((issue) => {
      // Filter by labels
      if (filters.labels?.length) {
        const hasAllLabels = filters.labels.every((label) => issue.labels.includes(label));
        if (!hasAllLabels) return false;
      }

      // Filter by assignee
      if (filters.assignee && issue.assignee !== filters.assignee) {
        return false;
      }

      // Filter by state
      if (filters.state && issue.state !== filters.state) {
        return false;
      }

      return true;
    });
  }

  private selectBestIssue(issues: Issue[]): Issue {
    // Sort by priority (high to low) and then by creation date (oldest first)
    return issues.sort((a, b) => {
      const priorityOrder = { critical: 4, high: 3, medium: 2, low: 1 };
      const aPriority = priorityOrder[a.priority] || 0;
      const bPriority = priorityOrder[b.priority] || 0;

      if (aPriority !== bPriority) {
        return bPriority - aPriority; // Higher priority first
      }

      return new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime();
    })[0];
  }
}
```

### State Management

```typescript
// @tamma/core/src/state/engine-state.ts
export enum EngineState {
  IDLE = 'idle',
  INITIALIZING = 'initializing',
  READY = 'ready',
  RUNNING = 'running',
  PAUSED = 'paused',
  ERROR = 'error',
  DISPOSED = 'disposed',
}

export interface EngineContext {
  mode: 'cli' | 'service' | 'web' | 'worker';
  config: TammaConfig;
  logger: ILogger;
  currentIssue?: Issue;
  currentPlan?: DevelopmentPlan;
  currentBranch?: Branch;
  startTime?: Date;
  lastActivity?: Date;
}

export class StateManager {
  private state: EngineState = EngineState.IDLE;
  private context: EngineContext;

  constructor(context: EngineContext) {
    this.context = context;
  }

  getState(): EngineState {
    return this.state;
  }

  setState(newState: EngineState): void {
    const oldState = this.state;
    this.state = newState;

    this.context.logger.info('Engine state changed', {
      from: oldState,
      to: newState,
      mode: this.context.mode,
    });
  }

  updateContext(updates: Partial<EngineContext>): void {
    this.context = { ...this.context, ...updates };
  }

  getContext(): EngineContext {
    return { ...this.context };
  }
}
```

### Error Handling

```typescript
// @tamma/core/src/errors/engine-error.ts
export class EngineError extends Error {
  constructor(
    public code: string,
    message: string,
    public context: Record<string, unknown> = {},
    public retryable: boolean = false
  ) {
    super(message);
    this.name = 'EngineError';
  }
}

export class WorkflowError extends EngineError {
  constructor(
    workflow: string,
    step: string,
    message: string,
    context: Record<string, unknown> = {}
  ) {
    super(
      `WORKFLOW_${workflow.toUpperCase()}_${step.toUpperCase()}_FAILED`,
      message,
      { workflow, step, ...context },
      true // Workflow errors are generally retryable
    );
  }
}

export class ConfigurationError extends EngineError {
  constructor(message: string, context: Record<string, unknown> = {}) {
    super(
      'CONFIGURATION_ERROR',
      message,
      context,
      false // Configuration errors are not retryable
    );
  }
}
```

## Testing Strategy

### Unit Tests

```typescript
// @tamma/core/tests/engine.test.ts
describe('TammaEngine', () => {
  let engine: TammaEngine;
  let mockConfig: TammaConfig;
  let mockLogger: ILogger;

  beforeEach(() => {
    mockConfig = createMockConfig();
    mockLogger = createMockLogger();
    engine = new TammaEngine(mockConfig, mockLogger);
  });

  describe('initialization', () => {
    it('should initialize with valid configuration', async () => {
      await expect(engine.initialize()).resolves.not.toThrow();
      expect(engine.getState()).toBe(EngineState.READY);
    });

    it('should handle provider initialization failures gracefully', async () => {
      mockConfig.aiProvider.providers[0].apiKey = 'invalid';

      await expect(engine.initialize()).rejects.toThrow(EngineError);
      expect(engine.getState()).toBe(EngineState.ERROR);
    });
  });

  describe('workflow execution', () => {
    beforeEach(async () => {
      await engine.initialize();
    });

    it('should execute complete workflow from issue to PR', async () => {
      const issue = await engine.selectIssue({ limit: 1 });
      expect(issue).toBeDefined();

      const analysis = await engine.analyzeIssue(issue!);
      expect(analysis).toBeDefined();

      const plan = await engine.generatePlan(analysis);
      expect(plan).toBeDefined();

      const branch = await engine.createBranch(plan);
      expect(branch).toBeDefined();

      const changes = await engine.implementCode(plan);
      expect(changes).toBeDefined();

      const testResults = await engine.runTests(changes);
      expect(testResults.passed).toBe(true);

      const pr = await engine.createPullRequest(changes);
      expect(pr).toBeDefined();
    });

    it('should dispose resources on shutdown', async () => {
      await engine.dispose();
      expect(engine.getState()).toBe(EngineState.DISPOSED);
    });
  });
});
```

### Integration Tests

```typescript
// @tamma/core/tests/integration/deployment-modes.test.ts
describe('Deployment Mode Integration', () => {
  const testCases = [
    { mode: 'cli' as const },
    { mode: 'service' as const },
    { mode: 'web' as const },
    { mode: 'worker' as const },
  ];

  testCases.forEach(({ mode }) => {
    describe(`${mode} mode`, () => {
      it('should create engine and execute workflow consistently', async () => {
        const context: LaunchContext = {
          mode,
          config: createTestConfig(),
          logger: createTestLogger(),
        };

        const engine = await createEngine(context);
        await engine.initialize();

        // Execute same workflow steps
        const issue = await engine.selectIssue({ limit: 1 });
        const analysis = await engine.analyzeIssue(issue!);
        const plan = await engine.generatePlan(analysis);

        // Verify consistent results across modes
        expect(issue).toBeDefined();
        expect(analysis.complexity).toBeDefined();
        expect(plan.steps.length).toBeGreaterThan(0);

        await engine.dispose();
      });
    });
  });
});
```

## Integration Points

### With Launch Wrappers

```typescript
// @tamma/cli/src/commands/run.ts
import { createEngine, TammaEngine } from '@tamma/core';
import { loadConfig } from '@tamma/config';

export async function runCommand(options: RunOptions): Promise<void> {
  const config = await loadConfig(options.config);
  const engine = await createEngine({
    mode: 'cli',
    config,
    logger: createCLILogger(),
  });

  await engine.initialize();
  // Execute workflow...
}

// @tamma/server/src/service.ts
import { createEngine, TammaEngine } from '@tamma/core';

export class TammaService {
  private engine: TammaEngine;

  constructor(private config: ServiceConfig) {
    this.engine = null; // Will be created per task
  }

  async processTask(task: Task): Promise<void> {
    const engine = await createEngine({
      mode: 'service',
      config: this.config.tamma,
      logger: createServiceLogger(),
    });

    await engine.initialize();
    // Execute workflow for task...
    await engine.dispose();
  }
}
```

### With Provider and Platform Packages

```typescript
// @tamma/core/src/engine.ts
import { createProvider } from '@tamma/providers';
import { createPlatform } from '@tamma/platforms';

export class TammaEngine {
  constructor(config: TammaConfig, logger: ILogger) {
    this.aiProvider = createProvider(config.aiProvider.default);
    this.gitPlatform = createPlatform(config.gitPlatform.default);
  }
}
```

## Configuration

### Core Engine Configuration

```typescript
// @tamma/core/src/config.ts
export interface CoreConfig {
  // Workflow configuration
  workflow: {
    maxRetries: number;
    retryDelay: number;
    timeoutMs: number;
  };

  // AI provider configuration
  aiProvider: {
    default: string;
    perWorkflowProviders: Record<string, string>;
  };

  // Git platform configuration
  gitPlatform: {
    default: string;
    defaultBranch: string;
  };

  // Quality gates
  qualityGates: {
    requireTests: boolean;
    requireCodeReview: boolean;
    maxComplexity: 'low' | 'medium' | 'high';
  };
}
```

## Performance Considerations

1. **Memory Usage**: Core engine should maintain minimal state in memory
2. **Resource Cleanup**: Proper disposal of AI provider and Git platform connections
3. **Concurrent Execution**: Support for multiple engine instances in service/web modes
4. **Error Recovery**: Graceful handling of transient failures with retry logic

## Security Considerations

1. **Credential Management**: Never log or expose API keys/tokens
2. **Input Validation**: Validate all inputs from external sources
3. **Error Information**: Avoid exposing sensitive information in error messages
4. **Resource Limits**: Implement timeouts and resource limits to prevent abuse

## Monitoring and Observability

1. **Structured Logging**: All operations logged with context (taskId, issueNumber, etc.)
2. **Metrics**: Track workflow execution times, success rates, error frequencies
3. **Health Checks**: Engine health status for deployment monitoring
4. **Tracing**: Request tracing across workflow steps for debugging

## Dependencies

### Internal Dependencies

- `@tamma/shared` - Shared types and utilities
- `@tamma/providers` - AI provider implementations
- `@tamma/platforms` - Git platform implementations

### External Dependencies

- `pino` - Structured logging
- `zod` - Configuration validation (via @tamma/config)

## Risks and Mitigations

### Risk: Core Engine Coupling

- **Description**: Core engine might become coupled to specific deployment modes
- **Mitigation**: Strict interface segregation, regular dependency reviews

### Risk: State Management Complexity

- **Description**: Managing state across different deployment modes could become complex
- **Mitigation**: Centralized state management with clear state transitions

### Risk: Performance Bottlenecks

- **Description**: Core engine could become a bottleneck in high-throughput scenarios
- **Mitigation**: Async operations, connection pooling, resource limits

## Success Metrics

1. **Code Reuse**: >90% of workflow logic shared across deployment modes
2. **Test Coverage**: >85% unit test coverage for core engine
3. **Performance**: Workflow execution time <10 minutes for typical issues
4. **Reliability**: >95% success rate for completed workflows
5. **Isolation**: Zero dependencies on deployment-mode-specific packages

---

## âš ï¸ MANDATORY: Before You Code

**ALL contributors MUST read and follow the comprehensive development process:**

ğŸ“– **[BEFORE_YOU_CODE.md](../../BEFORE_YOU_CODE.md)**

This mandatory guide includes:
- 7-Phase Development Workflow (Read â†’ Research â†’ Break Down â†’ TDD â†’ Quality Gates â†’ Failure Handling)
- Knowledge Base Usage (.dev/ directory: spikes, bugs, findings, decisions)
- TRACE/DEBUG Logging Requirements for all functions
- Test-Driven Development (TDD) mandatory workflow
- 100% Test Coverage requirement
- Build Success enforcement
- Automatic retry and developer alert procedures

**Failure to follow this process will result in rework.**

---

**Technical Context Created:** 2025-10-29  
**Last Updated:** 2025-10-29  
**Next Story:** 1.5-2 - CLI Mode Enhancement

### References

- **ğŸ”´ MANDATORY PROCESS:** [BEFORE_YOU_CODE.md](../../BEFORE_YOU_CODE.md)
- **Knowledge Base:** [.dev/README.md](../../.dev/README.md) - Search spikes, bugs, findings, decisions
