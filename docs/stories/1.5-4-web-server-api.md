# Story 1.5-4: Web Server & API

**Epic:** 1.5 - Deployment, Packaging & Operations  
**Status:** Ready for Development  
**Priority:** MVP Critical  
**Estimated Effort:** 5 days

## Overview

Implement REST API server with webhook endpoints, task queue integration, JWT authentication, and comprehensive API documentation. The web server enables external systems to interact with Tamma through HTTP APIs, receive webhook events from Git platforms, submit tasks for processing, and monitor system health and metrics.

## Technical Context

### ⚠️ Development Process Reminder

**Before implementing this story, ensure you have:**
1. ✅ Read [BEFORE_YOU_CODE.md](../../BEFORE_YOU_CODE.md)
2. ✅ Searched `.dev/` directory for related spikes, bugs, findings, and decisions
3. ✅ Reviewed relevant documentation in `docs/` directory
4. ✅ Checked existing code patterns for similar functionality
5. ✅ Planned TDD approach (Red-Green-Refactor cycle)


The web server provides the HTTP interface for Tamma's web mode deployment. It integrates with the service mode implementation from Story 1.5-3 for task processing, handles webhook events from GitHub/GitLab (preparation for Story 1.5-6), and provides authenticated APIs for task management and configuration. The server uses Fastify for high performance and includes built-in support for JWT authentication, CORS, and OpenAPI documentation.

The implementation must handle high-volume webhook events efficiently, provide secure API access, support real-time task monitoring via Server-Sent Events, and export metrics for Prometheus scraping.

## Acceptance Criteria

1. REST API server listens on configurable host:port (default 0.0.0.0:3000)
2. JWT authentication for all API endpoints (except webhooks, health)
3. Webhook endpoints for GitHub and GitLab with signature verification
4. Task submission API with validation and queuing
5. Task status API for monitoring task progress
6. Configuration API for runtime config updates (authenticated)
7. Health check, metrics, readiness, liveness endpoints
8. API documentation (OpenAPI/Swagger)
9. Unit tests validate API request/response handling
10. Integration tests validate end-to-end API workflows with authentication

## Implementation Details

### Web Server Package Structure

```
packages/
├── server/                  # @tamma/server - Service & Web launch wrapper
│   ├── src/
│   │   ├── web/             # Web server implementation
│   │   │   ├── server.ts    # Main web server class
│   │   │   ├── routes/      # API route handlers
│   │   │   │   ├── health.ts
│   │   │   │   ├── tasks.ts
│   │   │   │   ├── config.ts
│   │   │   │   ├── metrics.ts
│   │   │   │   └── index.ts
│   │   │   ├── middleware/  # Express/Fastify middleware
│   │   │   │   ├── auth.ts
│   │   │   │   ├── cors.ts
│   │   │   │   ├── validation.ts
│   │   │   │   ├── rate-limit.ts
│   │   │   │   └── index.ts
│   │   │   ├── schemas/     # JSON schemas for validation
│   │   │   │   ├── task.schema.ts
│   │   │   │   ├── config.schema.ts
│   │   │   │   └── index.ts
│   │   │   ├── docs/        # OpenAPI documentation
│   │   │   │   ├── openapi.yaml
│   │   │   │   └── swagger-ui.ts
│   │   │   └── index.ts
│   │   ├── webhooks/        # Webhook handlers (for Story 1.5-6)
│   │   │   ├── github.ts
│   │   │   ├── gitlab.ts
│   │   │   ├── signature.ts
│   │   │   └── index.ts
│   │   ├── service/         # Service mode (from Story 1.5-3)
│   │   │   └── ...
│   │   ├── queue/           # Task queue implementations
│   │   │   └── ...
│   │   ├── web.ts           # Web server entry point
│   │   ├── service.ts       # Service mode entry point
│   │   └── index.ts         # Server entry points
│   ├── tests/
│   │   ├── web/
│   │   │   ├── routes/
│   │   │   ├── middleware/
│   │   │   └── integration/
│   │   └── ...
│   ├── package.json
│   └── tsconfig.json
```

### Main Web Server Class

```typescript
// @tamma/server/src/web/server.ts
import Fastify, { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';
import { fastifyAuth } from '@fastify/auth';
import { fastifyJWT } from '@fastify/jwt';
import { fastifyCors } from '@fastify/cors';
import { fastifySwagger } from '@fastify/swagger';
import { fastifySwaggerUi } from '@fastify/swagger-ui';
import { fastifyRateLimit } from '@fastify/rate-limit';
import { fastifySse } from 'fastify-sse';
import { createLogger, ILogger } from '@tamma/observability';
import { ITaskQueue } from '../queue';
import { TammaService } from '../service/service';
import { WebServerConfig, TammaConfig } from '@tamma/config';

export interface WebServerMetrics {
  startTime: Date;
  requestsReceived: number;
  requestsCompleted: number;
  averageResponseTime: number;
  activeConnections: number;
  webhookEventsReceived: number;
  webhookEventsProcessed: number;
  webhookEventsFailed: number;
}

export class TammaWebServer {
  private fastify: FastifyInstance;
  private logger: ILogger;
  private config: WebServerConfig;
  private taskQueue: ITaskQueue;
  private service?: TammaService;
  private metrics: WebServerMetrics;
  private activeConnections = new Set<string>();

  constructor(config: WebServerConfig, taskQueue: ITaskQueue, service?: TammaService) {
    this.config = config;
    this.taskQueue = taskQueue;
    this.service = service;
    this.logger = createLogger('web-server', config.logLevel);
    this.metrics = this.initializeMetrics();
    this.fastify = this.createFastifyInstance();
  }

  private createFastifyInstance(): FastifyInstance {
    const fastify = Fastify({
      logger: false, // Use our own logger
      trustProxy: this.config.trustProxy,
      bodyLimit: this.config.bodyLimit || 1048576, // 1MB default
    });

    // Register plugins
    this.registerPlugins(fastify);
    this.registerRoutes(fastify);
    this.registerHooks(fastify);

    return fastify;
  }

  private async registerPlugins(fastify: FastifyInstance): Promise<void> {
    // JWT authentication
    await fastify.register(fastifyJWT, {
      secret: this.config.jwtSecret,
      sign: {
        expiresIn: this.config.jwtExpiresIn || '1h',
      },
      verify: {
        expiresIn: this.config.jwtExpiresIn || '1h',
      },
    });

    // Authentication support
    await fastify.register(fastifyAuth);

    // CORS support
    await fastify.register(fastifyCors, {
      origin: this.config.corsOrigins || ['http://localhost:3000'],
      credentials: true,
    });

    // Rate limiting
    await fastify.register(fastifyRateLimit, {
      max: this.config.rateLimit?.max || 100,
      timeWindow: this.config.rateLimit?.timeWindow || '1m',
      keyGenerator: (request) => {
        return request.ip || 'unknown';
      },
    });

    // Server-Sent Events
    await fastify.register(fastifySse);

    // Swagger/OpenAPI documentation
    if (this.config.enableDocs) {
      await fastify.register(fastifySwagger, {
        swagger: {
          info: {
            title: 'Tamma API',
            description: 'AI-powered autonomous development orchestration',
            version: '1.0.0',
            contact: {
              name: 'Tamma Team',
              url: 'https://github.com/meywd/tamma',
            },
          },
          host: `${this.config.host}:${this.config.port}`,
          schemes: ['http', 'https'],
          consumes: ['application/json'],
          produces: ['application/json'],
          securityDefinitions: {
            Bearer: {
              type: 'apiKey',
              name: 'Authorization',
              in: 'header',
            },
          },
        },
      });

      await fastify.register(fastifySwaggerUi, {
        routePrefix: '/docs',
        uiConfig: {
          docExpansion: 'full',
          deepLinking: false,
        },
      });
    }
  }

  private registerRoutes(fastify: FastifyInstance): void {
    // Health and metrics endpoints
    this.registerHealthRoutes(fastify);
    this.registerMetricsRoutes(fastify);

    // Task management endpoints
    this.registerTaskRoutes(fastify);

    // Configuration endpoints
    this.registerConfigRoutes(fastify);

    // Webhook endpoints
    this.registerWebhookRoutes(fastify);

    // Documentation endpoint
    if (this.config.enableDocs) {
      fastify.get('/docs', async (request, reply) => {
        return reply.redirect('/docs/');
      });
    }
  }

  private registerHooks(fastify: FastifyInstance): void {
    // Request logging
    fastify.addHook('onRequest', async (request, reply) => {
      this.metrics.requestsReceived++;
      const connectionId = `${Date.now()}-${Math.random()}`;
      this.activeConnections.add(connectionId);

      request.connectionId = connectionId;
      request.startTime = Date.now();

      this.logger.debug('Request received', {
        method: request.method,
        url: request.url,
        ip: request.ip,
        userAgent: request.headers['user-agent'],
      });
    });

    // Response logging
    fastify.addHook('onResponse', async (request, reply) => {
      const responseTime = Date.now() - (request.startTime as number);
      this.updateResponseTimeMetrics(responseTime);

      this.activeConnections.delete(request.connectionId as string);
      this.metrics.requestsCompleted++;

      this.logger.debug('Request completed', {
        method: request.method,
        url: request.url,
        statusCode: reply.statusCode,
        responseTime,
        ip: request.ip,
      });
    });

    // Error handling
    fastify.setErrorHandler(async (error, request, reply) => {
      this.logger.error('Request error', {
        error: error.message,
        stack: error.stack,
        method: request.method,
        url: request.url,
        ip: request.ip,
      });

      // Don't expose internal errors in production
      const statusCode = error.statusCode || 500;
      const message =
        process.env.NODE_ENV === 'production' && statusCode === 500
          ? 'Internal Server Error'
          : error.message;

      reply.status(statusCode).send({
        error: message,
        statusCode,
        timestamp: new Date().toISOString(),
        path: request.url,
      });
    });
  }

  private registerHealthRoutes(fastify: FastifyInstance): void {
    // Basic health check
    fastify.get(
      '/health',
      {
        schema: {
          description: 'Basic health check',
          tags: ['health'],
          response: {
            200: {
              type: 'object',
              properties: {
                status: { type: 'string' },
                timestamp: { type: 'string' },
                uptime: { type: 'number' },
              },
            },
          },
        },
      },
      async (request, reply) => {
        return {
          status: 'ok',
          timestamp: new Date().toISOString(),
          uptime: process.uptime(),
        };
      }
    );

    // Readiness probe
    fastify.get(
      '/ready',
      {
        schema: {
          description: 'Readiness probe',
          tags: ['health'],
        },
      },
      async (request, reply) => {
        try {
          // Check if task queue is healthy
          const queueHealth = await this.taskQueue.getHealthStatus();

          if (queueHealth.status !== 'healthy') {
            return reply.status(503).send({
              status: 'not_ready',
              reason: 'queue_unhealthy',
              queueHealth,
            });
          }

          // Check if service is healthy (if running)
          if (this.service) {
            const serviceHealth = await this.service.getHealthStatus();
            if (serviceHealth.status !== 'healthy') {
              return reply.status(503).send({
                status: 'not_ready',
                reason: 'service_unhealthy',
                serviceHealth,
              });
            }
          }

          return {
            status: 'ready',
            timestamp: new Date().toISOString(),
          };
        } catch (error) {
          this.logger.error('Readiness check failed', { error });
          return reply.status(503).send({
            status: 'not_ready',
            reason: 'check_failed',
            error: error.message,
          });
        }
      }
    );

    // Liveness probe
    fastify.get(
      '/live',
      {
        schema: {
          description: 'Liveness probe',
          tags: ['health'],
        },
      },
      async (request, reply) => {
        return {
          status: 'alive',
          timestamp: new Date().toISOString(),
          pid: process.pid,
        };
      }
    );
  }

  private registerMetricsRoutes(fastify: FastifyInstance): void {
    // Prometheus metrics endpoint
    fastify.get(
      '/metrics',
      {
        schema: {
          description: 'Prometheus metrics',
          tags: ['metrics'],
        },
      },
      async (request, reply) => {
        const metrics = this.getPrometheusMetrics();
        reply.type('text/plain');
        return metrics;
      }
    );

    // JSON metrics endpoint
    fastify.get(
      '/api/v1/metrics',
      {
        schema: {
          description: 'JSON metrics',
          tags: ['metrics'],
          response: {
            200: {
              type: 'object',
              properties: {
                requests: { type: 'object' },
                webhooks: { type: 'object' },
                connections: { type: 'object' },
                uptime: { type: 'number' },
              },
            },
          },
        },
      },
      async (request, reply) => {
        return {
          requests: {
            received: this.metrics.requestsReceived,
            completed: this.metrics.requestsCompleted,
            averageResponseTime: this.metrics.averageResponseTime,
          },
          webhooks: {
            received: this.metrics.webhookEventsReceived,
            processed: this.metrics.webhookEventsProcessed,
            failed: this.metrics.webhookEventsFailed,
          },
          connections: {
            active: this.activeConnections.size,
          },
          uptime: process.uptime(),
        };
      }
    );
  }

  private registerTaskRoutes(fastify: FastifyInstance): void {
    // Submit task
    fastify.post(
      '/api/v1/tasks',
      {
        preHandler: [fastify.auth([fastify.verifyJWT])],
        schema: {
          description: 'Submit a new task',
          tags: ['tasks'],
          security: [{ Bearer: [] }],
          body: {
            type: 'object',
            required: ['type', 'payload'],
            properties: {
              type: {
                type: 'string',
                enum: ['issue_assigned', 'issue_comment', 'pr_review_requested'],
              },
              priority: { type: 'number', minimum: 0, maximum: 3, default: 1 },
              payload: { type: 'object' },
              maxRetries: { type: 'number', minimum: 0, maximum: 10, default: 3 },
            },
          },
          response: {
            200: {
              type: 'object',
              properties: {
                taskId: { type: 'string' },
                status: { type: 'string' },
                createdAt: { type: 'string' },
              },
            },
          },
        },
      },
      async (request, reply) => {
        const taskPayload = request.body as any;

        try {
          const task = await this.taskQueue.enqueue({
            type: taskPayload.type,
            priority: taskPayload.priority || 1,
            payload: taskPayload.payload,
            maxRetries: taskPayload.maxRetries || 3,
          });

          this.logger.info('Task submitted via API', {
            taskId: task.id,
            type: task.type,
            submittedBy: request.user?.sub,
          });

          return {
            taskId: task.id,
            status: task.status,
            createdAt: task.createdAt.toISOString(),
          };
        } catch (error) {
          this.logger.error('Failed to submit task', { error, taskPayload });
          return reply.status(500).send({
            error: 'Failed to submit task',
            message: error.message,
          });
        }
      }
    );

    // Get task status
    fastify.get(
      '/api/v1/tasks/:id',
      {
        preHandler: [fastify.auth([fastify.verifyJWT])],
        schema: {
          description: 'Get task status',
          tags: ['tasks'],
          security: [{ Bearer: [] }],
          params: {
            type: 'object',
            required: ['id'],
            properties: {
              id: { type: 'string' },
            },
          },
          response: {
            200: {
              type: 'object',
              properties: {
                id: { type: 'string' },
                type: { type: 'string' },
                status: { type: 'string' },
                priority: { type: 'number' },
                retries: { type: 'number' },
                createdAt: { type: 'string' },
                startedAt: { type: 'string' },
                completedAt: { type: 'string' },
                error: { type: 'string' },
                result: { type: 'object' },
              },
            },
          },
        },
      },
      async (request, reply) => {
        const { id } = request.params as { id: string };

        try {
          const task = await this.taskQueue.get(id);

          if (!task) {
            return reply.status(404).send({
              error: 'Task not found',
              taskId: id,
            });
          }

          return {
            id: task.id,
            type: task.type,
            status: task.status,
            priority: task.priority,
            retries: task.retries,
            createdAt: task.createdAt.toISOString(),
            startedAt: task.startedAt?.toISOString(),
            completedAt: task.completedAt?.toISOString(),
            error: task.error,
            result: task.result,
          };
        } catch (error) {
          this.logger.error('Failed to get task', { error, taskId: id });
          return reply.status(500).send({
            error: 'Failed to get task',
            message: error.message,
          });
        }
      }
    );

    // List tasks
    fastify.get(
      '/api/v1/tasks',
      {
        preHandler: [fastify.auth([fastify.verifyJWT])],
        schema: {
          description: 'List tasks',
          tags: ['tasks'],
          security: [{ Bearer: [] }],
          querystring: {
            type: 'object',
            properties: {
              status: { type: 'string', enum: ['queued', 'in_progress', 'completed', 'failed'] },
              type: { type: 'string' },
              limit: { type: 'number', minimum: 1, maximum: 100, default: 20 },
              offset: { type: 'number', minimum: 0, default: 0 },
            },
          },
          response: {
            200: {
              type: 'object',
              properties: {
                tasks: {
                  type: 'array',
                  items: {
                    type: 'object',
                    properties: {
                      id: { type: 'string' },
                      type: { type: 'string' },
                      status: { type: 'string' },
                      priority: { type: 'number' },
                      createdAt: { type: 'string' },
                    },
                  },
                },
                total: { type: 'number' },
                limit: { type: 'number' },
                offset: { type: 'number' },
              },
            },
          },
        },
      },
      async (request, reply) => {
        const query = request.query as any;

        try {
          const tasks = await this.taskQueue.list({
            status: query.status,
            type: query.type,
            limit: query.limit,
            offset: query.offset,
          });

          return {
            tasks: tasks.map((task) => ({
              id: task.id,
              type: task.type,
              status: task.status,
              priority: task.priority,
              createdAt: task.createdAt.toISOString(),
            })),
            total: tasks.length,
            limit: query.limit,
            offset: query.offset,
          };
        } catch (error) {
          this.logger.error('Failed to list tasks', { error, query });
          return reply.status(500).send({
            error: 'Failed to list tasks',
            message: error.message,
          });
        }
      }
    );

    // Cancel task
    fastify.delete(
      '/api/v1/tasks/:id',
      {
        preHandler: [fastify.auth([fastify.verifyJWT])],
        schema: {
          description: 'Cancel a task',
          tags: ['tasks'],
          security: [{ Bearer: [] }],
          params: {
            type: 'object',
            required: ['id'],
            properties: {
              id: { type: 'string' },
            },
          },
        },
      },
      async (request, reply) => {
        const { id } = request.params as { id: string };

        try {
          await this.taskQueue.cancel(id);

          this.logger.info('Task cancelled via API', {
            taskId: id,
            cancelledBy: request.user?.sub,
          });

          return { status: 'cancelled', taskId: id };
        } catch (error) {
          this.logger.error('Failed to cancel task', { error, taskId: id });
          return reply.status(500).send({
            error: 'Failed to cancel task',
            message: error.message,
          });
        }
      }
    );

    // Task events stream (SSE)
    fastify.get(
      '/api/v1/tasks/events',
      {
        preHandler: [fastify.auth([fastify.verifyJWT])],
      },
      async (request, reply) => {
        const connectionId = `sse-${Date.now()}`;

        try {
          // Set up SSE connection
          reply.sse({ event: 'connected', data: { connectionId } });

          // Listen to task queue events and stream them
          const eventHandler = (event: any) => {
            reply.sse({
              event: 'task_update',
              data: JSON.stringify(event),
              id: connectionId,
            });
          };

          this.taskQueue.on('taskUpdated', eventHandler);

          // Clean up on disconnect
          request.raw.on('close', () => {
            this.taskQueue.off('taskUpdated', eventHandler);
            this.logger.debug('SSE connection closed', { connectionId });
          });
        } catch (error) {
          this.logger.error('SSE connection error', { error, connectionId });
          reply.sse({
            event: 'error',
            data: JSON.stringify({ error: error.message }),
          });
        }
      }
    );
  }

  private registerConfigRoutes(fastify: FastifyInstance): void {
    // Get current configuration
    fastify.get(
      '/api/v1/config',
      {
        preHandler: [fastify.auth([fastify.verifyJWT])],
        schema: {
          description: 'Get current configuration',
          tags: ['config'],
          security: [{ Bearer: [] }],
        },
      },
      async (request, reply) => {
        try {
          // Return sanitized configuration (no secrets)
          const config = await this.getSanitizedConfig();
          return config;
        } catch (error) {
          this.logger.error('Failed to get configuration', { error });
          return reply.status(500).send({
            error: 'Failed to get configuration',
            message: error.message,
          });
        }
      }
    );

    // Update configuration
    fastify.put(
      '/api/v1/config',
      {
        preHandler: [fastify.auth([fastify.verifyJWT])],
        schema: {
          description: 'Update configuration',
          tags: ['config'],
          security: [{ Bearer: [] }],
          body: {
            type: 'object',
            properties: {
              logLevel: { type: 'string', enum: ['error', 'warn', 'info', 'debug'] },
              maxConcurrentTasks: { type: 'number', minimum: 1, maximum: 20 },
              autoApprove: {
                type: 'object',
                properties: {
                  lowComplexity: { type: 'boolean' },
                  mediumComplexity: { type: 'boolean' },
                  maxEstimatedHours: { type: 'number', minimum: 1, maximum: 40 },
                },
              },
            },
          },
        },
      },
      async (request, reply) => {
        try {
          const updates = request.body as any;

          // Validate and apply configuration updates
          await this.updateConfiguration(updates);

          this.logger.info('Configuration updated via API', {
            updates,
            updatedBy: request.user?.sub,
          });

          return { status: 'updated', updates };
        } catch (error) {
          this.logger.error('Failed to update configuration', { error, updates });
          return reply.status(500).send({
            error: 'Failed to update configuration',
            message: error.message,
          });
        }
      }
    );

    // Validate configuration
    fastify.post(
      '/api/v1/config/validate',
      {
        preHandler: [fastify.auth([fastify.verifyJWT])],
        schema: {
          description: 'Validate configuration',
          tags: ['config'],
          security: [{ Bearer: [] }],
          body: {
            type: 'object',
          },
        },
      },
      async (request, reply) => {
        try {
          const config = request.body as any;
          const validation = await this.validateConfiguration(config);

          return {
            valid: validation.valid,
            errors: validation.errors,
            warnings: validation.warnings,
          };
        } catch (error) {
          this.logger.error('Failed to validate configuration', { error });
          return reply.status(500).send({
            error: 'Failed to validate configuration',
            message: error.message,
          });
        }
      }
    );
  }

  private registerWebhookRoutes(fastify: FastifyInstance): void {
    // GitHub webhook
    fastify.post(
      '/webhooks/github',
      {
        config: {
          rateLimit: { max: 300, timeWindow: '1m' }, // Higher limit for webhooks
        },
      },
      async (request, reply) => {
        try {
          const signature = request.headers['x-hub-signature-256'] as string;
          const event = request.headers['x-github-event'] as string;
          const payload = request.body;

          // Verify signature
          if (!this.verifyGitHubSignature(payload, signature)) {
            this.metrics.webhookEventsFailed++;
            return reply.status(401).send({ error: 'Invalid signature' });
          }

          this.metrics.webhookEventsReceived++;

          // Process webhook event
          await this.handleGitHubWebhook(event, payload);

          this.metrics.webhookEventsProcessed++;

          this.logger.info('GitHub webhook processed', {
            event,
            action: payload.action,
            repository: payload.repository?.full_name,
          });

          return { status: 'accepted' };
        } catch (error) {
          this.metrics.webhookEventsFailed++;
          this.logger.error('GitHub webhook processing failed', { error });
          return reply.status(500).send({
            error: 'Webhook processing failed',
            message: error.message,
          });
        }
      }
    );

    // GitLab webhook
    fastify.post(
      '/webhooks/gitlab',
      {
        config: {
          rateLimit: { max: 300, timeWindow: '1m' },
        },
      },
      async (request, reply) => {
        try {
          const token = request.headers['x-gitlab-token'] as string;
          const event = request.headers['x-gitlab-event'] as string;
          const payload = request.body;

          // Verify token
          if (token !== this.config.gitlabWebhookToken) {
            this.metrics.webhookEventsFailed++;
            return reply.status(401).send({ error: 'Invalid token' });
          }

          this.metrics.webhookEventsReceived++;

          // Process webhook event
          await this.handleGitLabWebhook(event, payload);

          this.metrics.webhookEventsProcessed++;

          this.logger.info('GitLab webhook processed', {
            event,
            objectKind: payload.object_kind,
            project: payload.project?.path_with_namespace,
          });

          return { status: 'accepted' };
        } catch (error) {
          this.metrics.webhookEventsFailed++;
          this.logger.error('GitLab webhook processing failed', { error });
          return reply.status(500).send({
            error: 'Webhook processing failed',
            message: error.message,
          });
        }
      }
    );
  }

  private verifyGitHubSignature(payload: any, signature: string): boolean {
    // Implementation will be added in Story 1.5-6
    return true; // Placeholder
  }

  private async handleGitHubWebhook(event: string, payload: any): Promise<void> {
    // Implementation will be added in Story 1.5-6
    this.logger.debug('GitHub webhook received', { event, payload });
  }

  private async handleGitLabWebhook(event: string, payload: any): Promise<void> {
    // Implementation will be added in Story 1.5-6
    this.logger.debug('GitLab webhook received', { event, payload });
  }

  private async getSanitizedConfig(): Promise<any> {
    // Return configuration without secrets
    return {
      mode: 'web',
      logLevel: this.config.logLevel,
      maxConcurrentTasks: this.config.maxConcurrentTasks,
      autoApprove: this.config.autoApprove,
      // Don't include secrets like jwtSecret, webhookSecrets, etc.
    };
  }

  private async updateConfiguration(updates: any): Promise<void> {
    // Apply configuration updates
    // This would typically update the running configuration
    // and potentially restart services if needed
    this.logger.info('Configuration updates applied', { updates });
  }

  private async validateConfiguration(config: any): Promise<any> {
    // Validate configuration against schema
    return {
      valid: true,
      errors: [],
      warnings: [],
    };
  }

  private getPrometheusMetrics(): string {
    const uptime = process.uptime();
    const memoryUsage = process.memoryUsage();

    return `
# HELP tamma_requests_total Total number of HTTP requests
# TYPE tamma_requests_total counter
tamma_requests_total ${this.metrics.requestsReceived}

# HELP tamma_request_duration_seconds Average request duration
# TYPE tamma_request_duration_seconds gauge
tamma_request_duration_seconds ${this.metrics.averageResponseTime / 1000}

# HELP tamma_webhook_events_total Total number of webhook events
# TYPE tamma_webhook_events_total counter
tamma_webhook_events_total{status="received"} ${this.metrics.webhookEventsReceived}
tamma_webhook_events_total{status="processed"} ${this.metrics.webhookEventsProcessed}
tamma_webhook_events_total{status="failed"} ${this.metrics.webhookEventsFailed}

# HELP tamma_active_connections Current number of active connections
# TYPE tamma_active_connections gauge
tamma_active_connections ${this.activeConnections.size}

# HELP tamma_uptime_seconds Process uptime in seconds
# TYPE tamma_uptime_seconds gauge
tamma_uptime_seconds ${uptime}

# HELP nodejs_memory_bytes Node.js memory usage
# TYPE nodejs_memory_bytes gauge
nodejs_memory_bytes{type="rss"} ${memoryUsage.rss}
nodejs_memory_bytes{type="heap_used"} ${memoryUsage.heapUsed}
nodejs_memory_bytes{type="heap_total"} ${memoryUsage.heapTotal}
nodejs_memory_bytes{type="external"} ${memoryUsage.external}
`;
  }

  private initializeMetrics(): WebServerMetrics {
    return {
      startTime: new Date(),
      requestsReceived: 0,
      requestsCompleted: 0,
      averageResponseTime: 0,
      activeConnections: 0,
      webhookEventsReceived: 0,
      webhookEventsProcessed: 0,
      webhookEventsFailed: 0,
    };
  }

  private updateResponseTimeMetrics(responseTime: number): void {
    const totalRequests = this.metrics.requestsCompleted + 1;
    const totalTime = this.metrics.averageResponseTime * (totalRequests - 1) + responseTime;
    this.metrics.averageResponseTime = totalTime / totalRequests;
  }

  async start(): Promise<void> {
    try {
      await this.fastify.listen({
        port: this.config.port,
        host: this.config.host,
      });

      this.logger.info('Web server started', {
        host: this.config.host,
        port: this.config.port,
        docs: this.config.enableDocs
          ? `http://${this.config.host}:${this.config.port}/docs`
          : undefined,
      });
    } catch (error) {
      this.logger.error('Failed to start web server', { error });
      throw error;
    }
  }

  async stop(): Promise<void> {
    try {
      await this.fastify.close();
      this.logger.info('Web server stopped');
    } catch (error) {
      this.logger.error('Error stopping web server', { error });
      throw error;
    }
  }

  getMetrics(): WebServerMetrics {
    return {
      ...this.metrics,
      activeConnections: this.activeConnections.size,
    };
  }
}

// Web server entry point
export async function startWebServer(config: WebServerConfig): Promise<TammaWebServer> {
  const taskQueue = createTaskQueue(config.queue);
  const service = config.enableServiceMode ? new TammaService(config.service) : undefined;

  const server = new TammaWebServer(config, taskQueue, service);
  await server.start();
  return server;
}
```

### Web Server Entry Point

```typescript
// @tamma/server/src/web.ts
import { startWebServer, TammaWebServer } from './web/server';
import { loadConfig } from '@tamma/config';
import { createLogger } from '@tamma/observability';

async function main(): Promise<void> {
  const logger = createLogger('web-main');

  try {
    // Load configuration
    const config = await loadConfig();

    if (config.mode !== 'web') {
      throw new Error('Invalid mode. Expected "web" mode.');
    }

    // Start web server
    const server = await startWebServer(config.web);

    // Handle graceful shutdown
    const shutdown = async (signal: string) => {
      logger.info(`Received ${signal}, shutting down web server`);
      try {
        await server.stop();
        process.exit(0);
      } catch (error) {
        logger.error('Error during shutdown', { error });
        process.exit(1);
      }
    };

    process.on('SIGTERM', () => shutdown('SIGTERM'));
    process.on('SIGINT', () => shutdown('SIGINT'));
  } catch (error) {
    logger.error('Failed to start web server', { error });
    process.exit(1);
  }
}

if (require.main === module) {
  main();
}
```

## Testing Strategy

### Unit Tests

```typescript
// @tamma/server/tests/web/server.test.ts
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { TammaWebServer } from '../../../src/web/server';
import { MemoryTaskQueue } from '../../../src/queue/memory-queue';

describe('TammaWebServer', () => {
  let server: TammaWebServer;
  let mockQueue: any;
  let config: any;

  beforeEach(() => {
    mockQueue = new MemoryTaskQueue({});
    vi.spyOn(mockQueue, 'enqueue');
    vi.spyOn(mockQueue, 'get');
    vi.spyOn(mockQueue, 'list');
    vi.spyOn(mockQueue, 'cancel');

    config = {
      host: '127.0.0.1',
      port: 0, // Random port for testing
      jwtSecret: 'test-secret',
      corsOrigins: ['http://localhost:3000'],
      enableDocs: true,
      logLevel: 'error', // Reduce noise in tests
      queue: { type: 'memory' },
    };

    server = new TammaWebServer(config, mockQueue);
  });

  afterEach(async () => {
    if (server) {
      await server.stop();
    }
    vi.clearAllMocks();
  });

  describe('server lifecycle', () => {
    it('should start and stop server', async () => {
      await server.start();
      await server.stop();
      // Should not throw
    });

    it('should handle graceful shutdown', async () => {
      await server.start();

      // Simulate SIGINT
      process.emit('SIGINT', 'SIGINT');

      // Wait for shutdown
      await new Promise((resolve) => setTimeout(resolve, 100));
    });
  });

  describe('health endpoints', () => {
    beforeEach(async () => {
      await server.start();
    });

    it('should respond to health check', async () => {
      const response = await fetch(
        `http://127.0.0.1:${server.fastify.server.address().port}/health`
      );
      const data = await response.json();

      expect(response.status).toBe(200);
      expect(data.status).toBe('ok');
      expect(data.timestamp).toBeDefined();
      expect(data.uptime).toBeDefined();
    });

    it('should respond to readiness probe', async () => {
      vi.spyOn(mockQueue, 'getHealthStatus').mockResolvedValue({
        status: 'healthy',
      });

      const response = await fetch(
        `http://127.0.0.1:${server.fastify.server.address().port}/ready`
      );
      const data = await response.json();

      expect(response.status).toBe(200);
      expect(data.status).toBe('ready');
    });

    it('should respond to liveness probe', async () => {
      const response = await fetch(`http://127.0.0.1:${server.fastify.server.address().port}/live`);
      const data = await response.json();

      expect(response.status).toBe(200);
      expect(data.status).toBe('alive');
      expect(data.pid).toBeDefined();
    });
  });

  describe('task endpoints', () => {
    beforeEach(async () => {
      await server.start();
    });

    it('should submit task with authentication', async () => {
      const token = await generateTestToken();

      mockQueue.enqueue.mockResolvedValue({
        id: 'test-task-1',
        type: 'issue_assigned',
        status: 'queued',
        createdAt: new Date(),
      });

      const response = await fetch(
        `http://127.0.0.1:${server.fastify.server.address().port}/api/v1/tasks`,
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${token}`,
          },
          body: JSON.stringify({
            type: 'issue_assigned',
            priority: 1,
            payload: {
              repository: 'test/repo',
              issue: { number: 123 },
            },
          }),
        }
      );

      const data = await response.json();

      expect(response.status).toBe(200);
      expect(data.taskId).toBe('test-task-1');
      expect(data.status).toBe('queued');
      expect(mockQueue.enqueue).toHaveBeenCalledWith({
        type: 'issue_assigned',
        priority: 1,
        payload: {
          repository: 'test/repo',
          issue: { number: 123 },
        },
        maxRetries: 3,
      });
    });

    it('should reject unauthenticated requests', async () => {
      const response = await fetch(
        `http://127.0.0.1:${server.fastify.server.address().port}/api/v1/tasks`,
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            type: 'issue_assigned',
            payload: {},
          }),
        }
      );

      expect(response.status).toBe(401);
    });

    it('should get task status', async () => {
      const token = await generateTestToken();

      mockQueue.get.mockResolvedValue({
        id: 'test-task-2',
        type: 'issue_assigned',
        status: 'completed',
        priority: 1,
        retries: 0,
        createdAt: new Date('2023-01-01T00:00:00Z'),
        completedAt: new Date('2023-01-01T01:00:00Z'),
        result: { success: true },
      });

      const response = await fetch(
        `http://127.0.0.1:${server.fastify.server.address().port}/api/v1/tasks/test-task-2`,
        {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        }
      );

      const data = await response.json();

      expect(response.status).toBe(200);
      expect(data.id).toBe('test-task-2');
      expect(data.status).toBe('completed');
      expect(data.result).toEqual({ success: true });
    });

    it('should return 404 for non-existent task', async () => {
      const token = await generateTestToken();

      mockQueue.get.mockResolvedValue(null);

      const response = await fetch(
        `http://127.0.0.1:${server.fastify.server.address().port}/api/v1/tasks/non-existent`,
        {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        }
      );

      expect(response.status).toBe(404);
    });
  });

  describe('webhook endpoints', () => {
    beforeEach(async () => {
      await server.start();
    });

    it('should accept GitHub webhook', async () => {
      const payload = {
        action: 'assigned',
        issue: {
          number: 123,
          title: 'Test Issue',
        },
        repository: {
          full_name: 'test/repo',
        },
      };

      const response = await fetch(
        `http://127.0.0.1:${server.fastify.server.address().port}/webhooks/github`,
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-GitHub-Event': 'issues',
            'X-Hub-Signature-256': 'test-signature',
          },
          body: JSON.stringify(payload),
        }
      );

      const data = await response.json();

      expect(response.status).toBe(200);
      expect(data.status).toBe('accepted');
    });

    it('should accept GitLab webhook', async () => {
      const payload = {
        object_kind: 'issue',
        object_attributes: {
          action: 'update',
          iid: 123,
          title: 'Test Issue',
        },
        project: {
          path_with_namespace: 'test/repo',
        },
      };

      const response = await fetch(
        `http://127.0.0.1:${server.fastify.server.address().port}/webhooks/gitlab`,
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-GitLab-Event': 'Issue Hook',
            'X-GitLab-Token': 'test-token',
          },
          body: JSON.stringify(payload),
        }
      );

      const data = await response.json();

      expect(response.status).toBe(200);
      expect(data.status).toBe('accepted');
    });
  });

  describe('metrics endpoints', () => {
    beforeEach(async () => {
      await server.start();
    });

    it('should return JSON metrics', async () => {
      const response = await fetch(
        `http://127.0.0.1:${server.fastify.server.address().port}/api/v1/metrics`
      );
      const data = await response.json();

      expect(response.status).toBe(200);
      expect(data.requests).toBeDefined();
      expect(data.webhooks).toBeDefined();
      expect(data.connections).toBeDefined();
      expect(data.uptime).toBeDefined();
    });

    it('should return Prometheus metrics', async () => {
      const response = await fetch(
        `http://127.0.0.1:${server.fastify.server.address().port}/metrics`
      );
      const text = await response.text();

      expect(response.status).toBe(200);
      expect(response.headers.get('content-type')).toBe('text/plain');
      expect(text).toContain('tamma_requests_total');
      expect(text).toContain('tamma_webhook_events_total');
      expect(text).toContain('nodejs_memory_bytes');
    });
  });
});

async function generateTestToken(): Promise<string> {
  // Generate a test JWT token for authentication
  // In real implementation, this would use the same JWT secret as the server
  return 'test-jwt-token';
}
```

### Integration Tests

```typescript
// @tamma/server/tests/integration/api-workflows.test.ts
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { TammaWebServer } from '../../src/web/server';
import { MemoryTaskQueue } from '../../src/queue/memory-queue';
import { loadConfig } from '@tamma/config';

describe('API Integration Tests', () => {
  let server: TammaWebServer;
  let config: any;
  let baseUrl: string;

  beforeAll(async () => {
    // Load test configuration
    config = await loadConfig('./test-config.yaml');
    config.mode = 'web';
    config.web.port = 0; // Random port for testing

    const queue = new MemoryTaskQueue({});
    server = new TammaWebServer(config.web, queue);
    await server.start();

    const address = server.fastify.server.address() as any;
    baseUrl = `http://127.0.0.1:${address.port}`;
  });

  afterAll(async () => {
    if (server) {
      await server.stop();
    }
  });

  describe('complete task workflow', () => {
    it('should submit task and monitor progress', async () => {
      // Submit task
      const submitResponse = await fetch(`${baseUrl}/api/v1/tasks`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${await getAuthToken()}`,
        },
        body: JSON.stringify({
          type: 'issue_assigned',
          priority: 1,
          payload: {
            repository: 'test/repo',
            issue: { number: 123 },
          },
        }),
      });

      expect(submitResponse.status).toBe(200);
      const submitData = await submitResponse.json();
      expect(submitData.taskId).toBeDefined();

      const taskId = submitData.taskId;

      // Check task status
      const statusResponse = await fetch(`${baseUrl}/api/v1/tasks/${taskId}`, {
        headers: {
          Authorization: `Bearer ${await getAuthToken()}`,
        },
      });

      expect(statusResponse.status).toBe(200);
      const statusData = await statusResponse.json();
      expect(statusData.id).toBe(taskId);
      expect(statusData.status).toBe('queued');

      // List tasks
      const listResponse = await fetch(`${baseUrl}/api/v1/tasks`, {
        headers: {
          Authorization: `Bearer ${await getAuthToken()}`,
        },
      });

      expect(listResponse.status).toBe(200);
      const listData = await listResponse.json();
      expect(listData.tasks).toBeInstanceOf(Array);
      expect(listData.tasks.some((t: any) => t.id === taskId)).toBe(true);
    });
  });

  describe('webhook to task workflow', () => {
    it('should process GitHub webhook and create task', async () => {
      const webhookPayload = {
        action: 'assigned',
        issue: {
          number: 456,
          title: 'Webhook Test Issue',
          body: 'Test issue from webhook',
        },
        repository: {
          full_name: 'test/webhook-repo',
        },
        assignee: {
          login: 'tamma-bot',
        },
      };

      const webhookResponse = await fetch(`${baseUrl}/webhooks/github`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-GitHub-Event': 'issues',
          'X-Hub-Signature-256': 'test-signature',
        },
        body: JSON.stringify(webhookPayload),
      });

      expect(webhookResponse.status).toBe(200);

      // Check that task was created (would need to inspect queue)
      // This is a simplified test - full integration would verify task creation
    });
  });

  describe('configuration management', () => {
    it('should get and update configuration', async () => {
      // Get current config
      const getResponse = await fetch(`${baseUrl}/api/v1/config`, {
        headers: {
          Authorization: `Bearer ${await getAuthToken()}`,
        },
      });

      expect(getResponse.status).toBe(200);
      const getConfig = await getResponse.json();
      expect(getConfig.mode).toBe('web');

      // Update config
      const updateResponse = await fetch(`${baseUrl}/api/v1/config`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${await getAuthToken()}`,
        },
        body: JSON.stringify({
          logLevel: 'debug',
          maxConcurrentTasks: 5,
        }),
      });

      expect(updateResponse.status).toBe(200);
      const updateData = await updateResponse.json();
      expect(updateData.status).toBe('updated');
    });
  });
});

async function getAuthToken(): Promise<string> {
  // In real implementation, this would authenticate with the service
  // For tests, return a mock token
  return 'test-auth-token';
}
```

## Configuration

### Web Server Configuration Schema

```typescript
// @tamma/config/src/schemas/web-server.schema.ts
export const WebServerConfigSchema = z.object({
  // Server settings
  host: z.string().default('0.0.0.0'),
  port: z.number().min(1).max(65535).default(3000),
  trustProxy: z.boolean().default(false),
  bodyLimit: z.number().min(1024).max(10485760).default(1048576), // 1MB

  // Authentication
  jwtSecret: z.string().min(32),
  jwtExpiresIn: z.string().default('1h'),

  // CORS
  corsOrigins: z.array(z.string()).default(['http://localhost:3000']),

  // Rate limiting
  rateLimit: z
    .object({
      max: z.number().min(1).default(100),
      timeWindow: z.string().default('1m'),
    })
    .default({}),

  // Documentation
  enableDocs: z.boolean().default(true),

  // Service mode integration
  enableServiceMode: z.boolean().default(true),
  service: ServiceConfigSchema.optional(),

  // Webhook settings
  githubWebhookSecret: z.string().optional(),
  gitlabWebhookToken: z.string().optional(),

  // Metrics
  enableMetrics: z.boolean().default(true),
  metricsPath: z.string().default('/metrics'),

  // Logging
  logLevel: z.enum(['error', 'warn', 'info', 'debug']).default('info'),
});

export type WebServerConfig = z.infer<typeof WebServerConfigSchema>;
```

## Performance Considerations

1. **Request Handling**: Fastify provides high-performance HTTP server
2. **Authentication**: JWT tokens with efficient verification
3. **Rate Limiting**: Prevent abuse and ensure fair usage
4. **Connection Management**: Proper cleanup of connections and resources
5. **Memory Usage**: Efficient request/response handling with streaming

## Security Considerations

1. **Authentication**: JWT-based authentication for all API endpoints
2. **Webhook Security**: Signature verification for GitHub webhooks
3. **Input Validation**: JSON schema validation for all request bodies
4. **Rate Limiting**: Prevent DoS attacks and abuse
5. **CORS**: Proper cross-origin resource sharing configuration
6. **Secrets Management**: Never expose secrets in API responses

## Monitoring and Observability

1. **Health Checks**: Comprehensive health endpoints for monitoring
2. **Metrics**: Prometheus-compatible metrics export
3. **Structured Logging**: Detailed request/response logging
4. **Real-time Events**: Server-Sent Events for task updates
5. **Performance Tracking**: Request latency and throughput metrics

## Dependencies

### External Dependencies

```json
{
  "dependencies": {
    "fastify": "^5.0.0",
    "@fastify/auth": "^5.0.0",
    "@fastify/jwt": "^8.0.0",
    "@fastify/cors": "^10.0.0",
    "@fastify/rate-limit": "^10.0.0",
    "@fastify/swagger": "^9.0.0",
    "@fastify/swagger-ui": "^3.0.0",
    "@fastify/sse": "^4.0.0"
  }
}
```

## Success Metrics

1. **API Performance**: <100ms response time for simple operations
2. **Webhook Processing**: <200ms webhook acknowledgment time
3. **Reliability**: >99.9% uptime, <0.1% error rate
4. **Security**: Zero authentication bypasses, no secret exposures
5. **Documentation**: Complete API documentation with examples

---

## ⚠️ MANDATORY: Before You Code

**ALL contributors MUST read and follow the comprehensive development process:**

📖 **[BEFORE_YOU_CODE.md](../../BEFORE_YOU_CODE.md)**

This mandatory guide includes:
- 7-Phase Development Workflow (Read → Research → Break Down → TDD → Quality Gates → Failure Handling)
- Knowledge Base Usage (.dev/ directory: spikes, bugs, findings, decisions)
- TRACE/DEBUG Logging Requirements for all functions
- Test-Driven Development (TDD) mandatory workflow
- 100% Test Coverage requirement
- Build Success enforcement
- Automatic retry and developer alert procedures

**Failure to follow this process will result in rework.**

---

**Technical Context Created:** 2025-10-29  
**Last Updated:** 2025-10-29  
**Next Story:** 1.5-5 - Docker Packaging

### References

- **🔴 MANDATORY PROCESS:** [BEFORE_YOU_CODE.md](../../BEFORE_YOU_CODE.md)
- **Knowledge Base:** [.dev/README.md](../../.dev/README.md) - Search spikes, bugs, findings, decisions
