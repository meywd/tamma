# Story 1.5-2: CLI Mode Enhancement

**Epic:** 1.5 - Deployment, Packaging & Operations  
**Status:** Ready for Development  
**Priority:** MVP Critical  
**Estimated Effort:** 4 days

## Overview

Enhance the CLI user experience with better prompts, progress tracking, color-coded output, enhanced error handling with actionable suggestions, and a configuration wizard. The CLI should provide an intuitive interactive experience for developers using Tamma directly from their terminal.

## Technical Context

### âš ï¸ Development Process Reminder

**Before implementing this story, ensure you have:**
1. âœ… Read [BEFORE_YOU_CODE.md](../../BEFORE_YOU_CODE.md)
2. âœ… Searched `.dev/` directory for related spikes, bugs, findings, and decisions
3. âœ… Reviewed relevant documentation in `docs/` directory
4. âœ… Checked existing code patterns for similar functionality
5. âœ… Planned TDD approach (Red-Green-Refactor cycle)


This story builds upon the basic CLI scaffolding from Epic 1 Story 1-9 and the core engine separation from Story 1.5-1. The enhanced CLI will use the `@tamma/core` package for workflow execution while providing a rich interactive experience using modern CLI libraries like `@inquirer/prompts`, `ora`, and `chalk`.

The CLI must maintain the same workflow logic as other deployment modes while providing human-friendly interactions, progress indicators, and helpful error messages with actionable resolution suggestions.

## Acceptance Criteria

1. CLI startup displays branded banner with version number
2. Interactive issue selection with fuzzy search and preview
3. Progress indicators (spinners) for long-running operations (analysis, code generation)
4. Color-coded output (errors in red, success in green, warnings in yellow)
5. Enhanced error messages with actionable suggestions for resolution
6. `--debug` flag enables verbose logging to file
7. Configuration wizard (`tamma init`) creates config file interactively
8. Unit tests validate CLI command parsing and output formatting
9. Integration tests validate end-to-end CLI workflows

## Implementation Details

### CLI Package Structure

```
packages/
â”œâ”€â”€ cli/                     # @tamma/cli - CLI launch wrapper
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ commands/        # CLI commands
â”‚   â”‚   â”‚   â”œâ”€â”€ run.ts       # Main workflow command
â”‚   â”‚   â”‚   â”œâ”€â”€ init.ts      # Configuration wizard
â”‚   â”‚   â”‚   â”œâ”€â”€ config.ts    # Config management
â”‚   â”‚   â”‚   â”œâ”€â”€ status.ts    # Show current status
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ prompts/         # Interactive prompts
â”‚   â”‚   â”‚   â”œâ”€â”€ issue-selection.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ plan-approval.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ config-wizard.ts
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ ui/              # UI components
â”‚   â”‚   â”‚   â”œâ”€â”€ spinner.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ banner.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ colors.ts
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ utils/           # CLI utilities
â”‚   â”‚   â”‚   â”œâ”€â”€ error-handler.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ logger.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ formatter.ts
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ index.ts         # CLI entry point
â”‚   â”‚   â””â”€â”€ bin.ts           # Shebang executable
â”‚   â”œâ”€â”€ tests/
â”‚   â”‚   â”œâ”€â”€ commands/
â”‚   â”‚   â”œâ”€â”€ prompts/
â”‚   â”‚   â””â”€â”€ integration/
â”‚   â”œâ”€â”€ package.json
â”‚   â””â”€â”€ tsconfig.json
```

### Main CLI Entry Point

```typescript
// @tamma/cli/src/index.ts
#!/usr/bin/env node

import { Command } from 'commander';
import chalk from 'chalk';
import { showBanner } from './ui/banner';
import { runCommand } from './commands/run';
import { initCommand } from './commands/init';
import { configCommand } from './commands/config';
import { statusCommand } from './commands/status';
import { createCLILogger } from './utils/logger';
import { loadConfig } from '@tamma/config';

const program = new Command();

async function main() {
  // Show banner for all commands except --help and --version
  if (!process.argv.includes('--help') && !process.argv.includes('--version')) {
    showBanner();
  }

  program
    .name('tamma')
    .description('AI-powered autonomous development orchestration')
    .version(getVersion());

  program
    .command('run')
    .description('Run autonomous development workflow')
    .option('-i, --issue <number>', 'Specific issue number to work on')
    .option('-c, --config <path>', 'Path to configuration file')
    .option('-d, --debug', 'Enable debug logging')
    .option('--no-interactive', 'Run in non-interactive mode')
    .action(runCommand);

  program
    .command('init')
    .description('Initialize Tamma configuration')
    .option('-f, --force', 'Overwrite existing configuration')
    .action(initCommand);

  program
    .command('config')
    .description('Manage configuration')
    .option('--show', 'Show current configuration')
    .option('--validate', 'Validate configuration')
    .action(configCommand);

  program
    .command('status')
    .description('Show current Tamma status')
    .action(statusCommand);

  await program.parseAsync();
}

main().catch(error => {
  console.error(chalk.red('âŒ Fatal error:'), error.message);
  if (process.env.DEBUG) {
    console.error(error.stack);
  }
  process.exit(1);
});
```

### Branded Banner

```typescript
// @tamma/cli/src/ui/banner.ts
import chalk from 'chalk';
import figlet from 'figlet';

export function showBanner(): void {
  const logo = figlet.textSync('Tamma', {
    font: 'Standard',
    horizontalLayout: 'default',
    verticalLayout: 'default',
  });

  console.log(chalk.cyan(logo));
  console.log(chalk.gray('AI-powered autonomous development orchestration'));
  console.log(chalk.gray(`Version: ${getVersion()}`));
  console.log(); // Empty line for spacing
}

function getVersion(): string {
  try {
    const packageJson = require('../../package.json');
    return packageJson.version;
  } catch {
    return 'unknown';
  }
}
```

### Enhanced Run Command

```typescript
// @tamma/cli/src/commands/run.ts
import chalk from 'chalk';
import ora, { Ora } from 'ora';
import { select, confirm } from '@inquirer/prompts';
import { createEngine } from '@tamma/core';
import { loadConfig } from '@tamma/config';
import { createCLILogger } from '../utils/logger';
import { handleCLIError } from '../utils/error-handler';
import { promptIssueSelection } from '../prompts/issue-selection';
import { promptPlanApproval } from '../prompts/plan-approval';
import { formatPlan, formatIssue, formatTestResults } from '../utils/formatter';

interface RunOptions {
  issue?: string;
  config?: string;
  debug?: boolean;
  interactive?: boolean;
}

export async function runCommand(options: RunOptions): Promise<void> {
  const spinner = ora('Initializing Tamma...').start();

  try {
    // Load configuration
    const config = await loadConfig(options.config);
    const logger = createCLILogger(options.debug || false);

    // Create and initialize engine
    const engine = await createEngine({ mode: 'cli', config, logger });
    await engine.initialize();

    spinner.succeed('Tamma initialized successfully');

    // Issue selection
    let issue;
    if (options.issue) {
      spinner.start('Fetching specified issue...');
      issue = await engine.selectIssue({ number: parseInt(options.issue) });
      spinner.succeed(`Issue #${issue?.number} loaded`);
    } else if (options.interactive) {
      spinner.start('Fetching available issues...');
      const issues = await engine.selectIssue({ limit: 20, state: 'open' });
      spinner.succeed(`Found ${issues.length} issues`);

      issue = await promptIssueSelection(issues);
    } else {
      spinner.start('Selecting best issue...');
      issue = await engine.selectIssue({ limit: 1, state: 'open' });
      spinner.succeed(`Auto-selected issue #${issue?.number}`);
    }

    if (!issue) {
      console.log(chalk.yellow('No suitable issues found.'));
      return;
    }

    console.log(chalk.blue(`\nğŸ“‹ Working on: ${issue.title} (#${issue.number})\n`));
    console.log(formatIssue(issue));

    // Issue analysis
    const analysisSpinner = ora('Analyzing issue complexity...').start();
    const analysis = await engine.analyzeIssue(issue);
    analysisSpinner.succeed(`Analysis complete: ${analysis.complexity} complexity`);

    console.log(chalk.gray(`\nğŸ“Š Analysis Summary:`));
    console.log(chalk.gray(`   Complexity: ${analysis.complexity}`));
    console.log(chalk.gray(`   Estimated effort: ${analysis.estimatedEffort} hours`));
    console.log(chalk.gray(`   Risk level: ${analysis.riskLevel}`));

    // Plan generation
    const planSpinner = ora('Generating development plan...').start();
    const plan = await engine.generatePlan(analysis);
    planSpinner.succeed('Development plan ready');

    // Show plan and get approval
    console.log('\nğŸ“ Proposed Development Plan:\n');
    console.log(formatPlan(plan));

    if (options.interactive) {
      const approved = await promptPlanApproval(plan);
      if (!approved) {
        console.log(chalk.yellow('Plan rejected. Exiting.'));
        return;
      }
    } else {
      console.log(chalk.green('\nâœ… Plan auto-approved (non-interactive mode)'));
    }

    // Execute plan with progress tracking
    await executePlanWithProgress(engine, plan);

    console.log(chalk.green(`\nğŸ‰ Workflow completed successfully!\n`));
  } catch (error) {
    spinner.fail('Error occurred');
    handleCLIError(error, config);
  }
}

async function executePlanWithProgress(engine: any, plan: any): Promise<void> {
  const steps = [
    { name: 'Creating branch', action: () => engine.createBranch(plan) },
    { name: 'Implementing code', action: () => engine.implementCode(plan) },
    { name: 'Running tests', action: () => engine.runTests() },
    { name: 'Creating pull request', action: () => engine.createPullRequest() },
  ];

  for (const step of steps) {
    const spinner = ora(step.name).start();

    try {
      const result = await step.action();

      if (step.name === 'Running tests') {
        spinner.succeed(`Tests passed: ${result.passed}/${result.total}`);
        console.log(formatTestResults(result));
      } else {
        spinner.succeed(`${step.name} completed`);
      }
    } catch (error) {
      spinner.fail(`${step.name} failed`);
      throw error;
    }
  }
}
```

### Interactive Issue Selection

```typescript
// @tamma/cli/src/prompts/issue-selection.ts
import { select } from '@inquirer/prompts';
import chalk from 'chalk';
import { Issue } from '@tamma/shared';

export async function promptIssueSelection(issues: Issue[]): Promise<Issue> {
  if (issues.length === 0) {
    throw new Error('No issues available for selection');
  }

  const choices = issues.map((issue) => ({
    name: `#${issue.number}: ${issue.title}`,
    value: issue.number,
    description: `${chalk.gray(issue.labels.join(', '))} - ${chalk.cyan(`Priority: ${issue.priority}`)}`,
  }));

  const answer = await select({
    message: 'Select an issue to work on:',
    choices,
    pageSize: 10,
  });

  const selectedIssue = issues.find((i) => i.number === answer);
  if (!selectedIssue) {
    throw new Error('Selected issue not found');
  }

  return selectedIssue;
}
```

### Plan Approval Prompt

```typescript
// @tamma/cli/src/prompts/plan-approval.ts
import { confirm } from '@inquirer/prompts';
import chalk from 'chalk';
import { DevelopmentPlan } from '@tamma/shared';

export async function promptPlanApproval(plan: DevelopmentPlan): Promise<boolean> {
  console.log(chalk.yellow('\nâš ï¸  Review the plan carefully before approval:'));
  console.log(chalk.gray('   â€¢ This will create a new branch and implement changes'));
  console.log(chalk.gray('   â€¢ Tests will be run and a pull request will be created'));
  console.log(chalk.gray('   â€¢ You can always review and modify the PR before merging\n'));

  const approved = await confirm({
    message: 'Do you approve this development plan?',
    default: false,
  });

  return approved;
}
```

### Configuration Wizard

```typescript
// @tamma/cli/src/commands/init.ts
import chalk from 'chalk';
import { input, password, select, confirm } from '@inquirer/prompts';
import { writeFileSync } from 'fs';
import { join } from 'path';
import { homedir } from 'os';
import { ensureDirSync } from 'fs-extra';

interface InitOptions {
  force?: boolean;
}

export async function initCommand(options: InitOptions): Promise<void> {
  console.log(chalk.blue("ğŸš€ Welcome to Tamma! Let's configure your setup.\n"));

  const configDir = join(homedir(), '.tamma');
  const configFile = join(configDir, 'config.yaml');

  // Check if config already exists
  if (!options.force && require('fs').existsSync(configFile)) {
    console.log(chalk.yellow('âš ï¸  Configuration file already exists:'));
    console.log(chalk.gray(`   ${configFile}`));

    const overwrite = await confirm({
      message: 'Do you want to overwrite it?',
      default: false,
    });

    if (!overwrite) {
      console.log(chalk.gray('Configuration initialization cancelled.'));
      return;
    }
  }

  // Create config directory
  ensureDirSync(configDir);

  // Gather configuration
  const config = await gatherConfiguration();

  // Write configuration file
  const yamlContent = generateYAMLConfig(config);
  writeFileSync(configFile, yamlContent, 'utf-8');

  console.log(chalk.green('\nâœ… Configuration saved successfully!'));
  console.log(chalk.gray(`   File: ${configFile}`));
  console.log(chalk.gray('\nNext steps:'));
  console.log(chalk.gray('   1. Set your environment variables (API keys, tokens)'));
  console.log(chalk.gray('   2. Run "tamma run" to start your first workflow'));
}

async function gatherConfiguration(): Promise<any> {
  const config: any = {
    mode: 'cli',
    logLevel: 'info',
  };

  // AI Provider configuration
  console.log(chalk.cyan('ğŸ¤– AI Provider Configuration'));
  const aiProvider = await select({
    message: 'Select your preferred AI provider:',
    choices: [
      { name: 'Anthropic Claude', value: 'anthropic-claude' },
      { name: 'OpenAI GPT', value: 'openai' },
      { name: 'GitHub Copilot', value: 'github-copilot' },
      { name: 'Google Gemini', value: 'google-gemini' },
    ],
  });

  config.aiProvider = {
    default: aiProvider,
    providers: [
      {
        name: aiProvider,
        enabled: true,
        apiKey: '${' + aiProvider.toUpperCase().replace('-', '_') + '_API_KEY}',
      },
    ],
  };

  // Git Platform configuration
  console.log(chalk.cyan('\nğŸ”§ Git Platform Configuration'));
  const gitPlatform = await select({
    message: 'Select your Git platform:',
    choices: [
      { name: 'GitHub', value: 'github' },
      { name: 'GitLab', value: 'gitlab' },
      { name: 'Bitbucket', value: 'bitbucket' },
    ],
  });

  config.gitPlatform = {
    default: gitPlatform,
    platforms: [
      {
        name: gitPlatform,
        enabled: true,
        token: '${' + gitPlatform.toUpperCase() + '_TOKEN}',
      },
    ],
  };

  // Workflow preferences
  console.log(chalk.cyan('\nâš™ï¸  Workflow Preferences'));
  config.workflow = {
    autoApproveLowComplexity: await confirm({
      message: 'Auto-approve low complexity issues?',
      default: true,
    }),
    requireTests: await confirm({
      message: 'Require tests for all changes?',
      default: true,
    }),
    maxRetries: 3,
  };

  return config;
}

function generateYAMLConfig(config: any): string {
  // Simple YAML generator (in production, use a proper YAML library)
  return `# Tamma Configuration
mode: ${config.mode}
logLevel: ${config.logLevel}

aiProvider:
  default: ${config.aiProvider.default}
  providers:
    - name: ${config.aiProvider.providers[0].name}
      enabled: true
      apiKey: ${config.aiProvider.providers[0].apiKey}

gitPlatform:
  default: ${config.gitPlatform.default}
  platforms:
    - name: ${config.gitPlatform.platforms[0].name}
      enabled: true
      token: ${config.gitPlatform.platforms[0].token}

workflow:
  autoApproveLowComplexity: ${config.workflow.autoApproveLowComplexity}
  requireTests: ${config.workflow.requireTests}
  maxRetries: ${config.workflow.maxRetries}
`;
}
```

### Enhanced Error Handler

```typescript
// @tamma/cli/src/utils/error-handler.ts
import chalk from 'chalk';
import { TammaError } from '@tamma/core';

export function handleCLIError(error: any, config?: any): void {
  console.error(chalk.red('\nâŒ An error occurred:'), error.message);

  // Provide actionable suggestions based on error type
  if (error instanceof TammaError) {
    switch (error.code) {
      case 'AI_PROVIDER_ERROR':
        console.error(chalk.yellow('\nğŸ’¡ Suggestion: Check your AI provider configuration'));
        console.error(chalk.gray('   â€¢ Verify API key is set and valid'));
        console.error(chalk.gray('   â€¢ Check provider service status'));
        console.error(chalk.gray('   â€¢ Run "tamma config --show" to review configuration'));
        break;

      case 'GIT_PLATFORM_ERROR':
        console.error(chalk.yellow('\nğŸ’¡ Suggestion: Check your Git platform configuration'));
        console.error(chalk.gray('   â€¢ Verify access token has required permissions'));
        console.error(chalk.gray('   â€¢ Check repository access and permissions'));
        console.error(chalk.gray('   â€¢ Ensure token is not expired'));
        break;

      case 'CONFIGURATION_ERROR':
        console.error(chalk.yellow('\nğŸ’¡ Suggestion: Fix configuration issues'));
        console.error(chalk.gray('   â€¢ Run "tamma config --validate" to check configuration'));
        console.error(chalk.gray('   â€¢ Use "tamma init" to recreate configuration'));
        console.error(chalk.gray('   â€¢ Check environment variables are set'));
        break;

      case 'WORKFLOW_EXECUTION_FAILED':
        console.error(chalk.yellow('\nğŸ’¡ Suggestion: Check workflow state and inputs'));
        console.error(chalk.gray('   â€¢ Verify issue exists and is accessible'));
        console.error(chalk.gray('   â€¢ Check repository is in a clean state'));
        console.error(chalk.gray('   â€¢ Review workflow logs for details'));
        break;

      default:
        console.error(chalk.yellow('\nğŸ’¡ Suggestion: Run with --debug for detailed logs'));
        console.error(chalk.gray('   â€¢ Check the error context above'));
        console.error(chalk.gray('   â€¢ Report the issue if it persists'));
    }
  } else {
    // Generic error handling
    console.error(chalk.yellow('\nğŸ’¡ General suggestions:'));
    console.error(chalk.gray('   â€¢ Run with --debug flag for more information'));
    console.error(chalk.gray('   â€¢ Check your internet connection'));
    console.error(chalk.gray('   â€¢ Verify all required environment variables are set'));
  }

  // Show debug information if available
  if (process.env.DEBUG && error.stack) {
    console.error(chalk.gray('\nğŸ“‹ Debug information:'));
    console.error(chalk.gray(error.stack));
  }

  process.exit(1);
}
```

### CLI Logger

```typescript
// @tamma/cli/src/utils/logger.ts
import pino from 'pino';
import { writeFileSync, existsSync, mkdirSync } from 'fs';
import { join } from 'path';
import { homedir } from 'os';

export function createCLILogger(debug: boolean = false): pino.Logger {
  const logDir = join(homedir(), '.tamma', 'logs');

  if (!existsSync(logDir)) {
    mkdirSync(logDir, { recursive: true });
  }

  const logFile = join(logDir, `tamma-${new Date().toISOString().split('T')[0]}.log`);

  const logger = pino(
    {
      level: debug ? 'debug' : 'info',
      transport: debug
        ? {
            target: 'pino-pretty',
            options: {
              colorize: true,
              translateTime: 'HH:MM:ss Z',
              ignore: 'pid,hostname',
            },
          }
        : undefined,
    },
    debug ? pino.destination(logFile) : process.stdout
  );

  return logger;
}
```

### Output Formatters

```typescript
// @tamma/cli/src/utils/formatter.ts
import chalk from 'chalk';
import { Issue, DevelopmentPlan, TestResults } from '@tamma/shared';

export function formatIssue(issue: Issue): string {
  let output = '';

  output += chalk.gray(`   State: ${issue.state}\n`);
  output += chalk.gray(`   Labels: ${issue.labels.join(', ') || 'None'}\n`);
  output += chalk.gray(`   Priority: ${issue.priority}\n`);
  output += chalk.gray(`   Assignee: ${issue.assignee || 'Unassigned'}\n`);
  output += chalk.gray(`   Created: ${new Date(issue.createdAt).toLocaleDateString()}\n`);

  if (issue.body) {
    output += chalk.gray(`\n   Description:\n`);
    output += chalk.gray(`   ${issue.body.split('\n').slice(0, 3).join('\n   ')}`);
    if (issue.body.split('\n').length > 3) {
      output += chalk.gray('\n   ...');
    }
  }

  return output;
}

export function formatPlan(plan: DevelopmentPlan): string {
  let output = '';

  output += chalk.cyan(`   Estimated Time: ${plan.estimatedHours} hours\n`);
  output += chalk.cyan(`   Complexity: ${plan.complexity}\n`);
  output += chalk.cyan(`   Risk Level: ${plan.riskLevel}\n\n`);

  output += chalk.white('   Steps:\n');
  plan.steps.forEach((step, index) => {
    const status = step.completed ? chalk.green('âœ“') : chalk.gray('â—‹');
    output += `   ${status} ${index + 1}. ${step.description}\n`;
    if (step.estimatedTime) {
      output += chalk.gray(`      Estimated: ${step.estimatedTime} minutes\n`);
    }
  });

  return output;
}

export function formatTestResults(results: TestResults): string {
  let output = '';

  if (results.passed) {
    output += chalk.green(`   âœ“ ${results.passed} tests passed`);
  }

  if (results.failed) {
    output += chalk.red(`   âœ— ${results.failed} tests failed`);
  }

  if (results.skipped) {
    output += chalk.yellow(`   â—‹ ${results.skipped} tests skipped`);
  }

  output += chalk.gray(` (${results.total} total)\n`);

  if (results.coverage) {
    output += chalk.gray(`   Coverage: ${results.coverage}%\n`);
  }

  return output;
}
```

## Testing Strategy

### Unit Tests

```typescript
// @tamma/cli/tests/commands/run.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { runCommand } from '../../../src/commands/run';
import { createEngine } from '@tamma/core';

vi.mock('@tamma/core');
vi.mock('@inquirer/prompts');

describe('runCommand', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should execute workflow with specified issue', async () => {
    const mockEngine = {
      initialize: vi.fn(),
      selectIssue: vi.fn().mockResolvedValue({ number: 123, title: 'Test Issue' }),
      analyzeIssue: vi.fn().mockResolvedValue({ complexity: 'low' }),
      generatePlan: vi.fn().mockResolvedValue({ steps: [] }),
      createBranch: vi.fn(),
      implementCode: vi.fn(),
      runTests: vi.fn().mockResolvedValue({ passed: true, total: 10 }),
      createPullRequest: vi.fn(),
    };

    vi.mocked(createEngine).mockResolvedValue(mockEngine);

    await runCommand({
      issue: '123',
      interactive: false,
      debug: false,
    });

    expect(mockEngine.selectIssue).toHaveBeenCalledWith({ number: 123 });
    expect(mockEngine.analyzeIssue).toHaveBeenCalled();
    expect(mockEngine.generatePlan).toHaveBeenCalled();
  });

  it('should handle interactive mode with prompts', async () => {
    // Test interactive prompt handling
  });

  it('should handle errors gracefully', async () => {
    const mockEngine = {
      initialize: vi.fn().mockRejectedValue(new Error('Test error')),
    };

    vi.mocked(createEngine).mockResolvedValue(mockEngine);

    await expect(runCommand({ interactive: false })).rejects.toThrow();
  });
});
```

### Integration Tests

```typescript
// @tamma/cli/tests/integration/end-to-end.test.ts
import { describe, it, expect } from 'vitest';
import { execSync } from 'child_process';
import { existsSync, unlinkSync } from 'fs';
import { join } from 'path';

describe('CLI Integration Tests', () => {
  const testConfigPath = join(__dirname, 'test-config.yaml');

  afterEach(() => {
    if (existsSync(testConfigPath)) {
      unlinkSync(testConfigPath);
    }
  });

  it('should show help information', () => {
    const result = execSync('node packages/cli/src/bin.js --help', {
      encoding: 'utf-8',
    });

    expect(result).toContain('AI-powered autonomous development');
    expect(result).toContain('run');
    expect(result).toContain('init');
  });

  it('should initialize configuration', () => {
    const result = execSync(`node packages/cli/src/bin.js init --force`, {
      encoding: 'utf-8',
      cwd: __dirname,
    });

    expect(result).toContain('Configuration saved successfully');
    expect(existsSync(join(__dirname, '.tamma', 'config.yaml'))).toBe(true);
  });

  it('should validate configuration', () => {
    execSync('node packages/cli/src/bin.js init --force', {
      cwd: __dirname,
    });

    const result = execSync('node packages/cli/src/bin.js config --validate', {
      encoding: 'utf-8',
      cwd: __dirname,
    });

    expect(result).toContain('Configuration is valid');
  });
});
```

## Dependencies

### Package Dependencies

```json
{
  "name": "@tamma/cli",
  "version": "1.0.0",
  "description": "Tamma CLI - interactive command-line interface",
  "main": "dist/index.js",
  "bin": {
    "tamma": "dist/bin.js"
  },
  "scripts": {
    "build": "tsc",
    "test": "vitest",
    "dev": "tsx src/index.ts"
  },
  "dependencies": {
    "@tamma/core": "workspace:*",
    "@tamma/config": "workspace:*",
    "@inquirer/prompts": "^5.0.0",
    "commander": "^12.0.0",
    "ora": "^8.0.0",
    "chalk": "^5.3.0",
    "figlet": "^1.7.0",
    "pino": "^9.0.0",
    "pino-pretty": "^11.0.0",
    "fs-extra": "^11.2.0"
  },
  "devDependencies": {
    "@types/node": "^22.0.0",
    "@types/figlet": "^1.5.8",
    "@types/fs-extra": "^11.0.4",
    "typescript": "^5.7.0",
    "tsx": "^4.11.0",
    "vitest": "^2.0.0"
  }
}
```

## Performance Considerations

1. **Startup Time**: CLI should start in <2 seconds
2. **Interactive Responsiveness**: Prompts should respond in <100ms
3. **Memory Usage**: Keep CLI memory footprint <100MB
4. **Progress Updates**: Provide frequent progress feedback for long operations

## Security Considerations

1. **Input Validation**: Validate all user inputs
2. **Credential Protection**: Never log or expose API keys
3. **File Permissions**: Secure config file permissions (600)
4. **Command Injection**: Prevent command injection in user inputs

## Accessibility

1. **Color Support**: Respect NO_COLOR environment variable
2. **Screen Readers**: Provide text-only output options
3. **Keyboard Navigation**: Full keyboard support in prompts
4. **Error Messages**: Clear, actionable error descriptions

## Success Metrics

1. **User Experience**: User satisfaction score >4.5/5
2. **Error Recovery**: >90% of errors have actionable suggestions
3. **Performance**: CLI startup <2 seconds, prompt response <100ms
4. **Adoption**: >80% of users successfully complete init wizard
5. **Support**: <5% of users require support for basic CLI usage

---

## âš ï¸ MANDATORY: Before You Code

**ALL contributors MUST read and follow the comprehensive development process:**

ğŸ“– **[BEFORE_YOU_CODE.md](../../BEFORE_YOU_CODE.md)**

This mandatory guide includes:
- 7-Phase Development Workflow (Read â†’ Research â†’ Break Down â†’ TDD â†’ Quality Gates â†’ Failure Handling)
- Knowledge Base Usage (.dev/ directory: spikes, bugs, findings, decisions)
- TRACE/DEBUG Logging Requirements for all functions
- Test-Driven Development (TDD) mandatory workflow
- 100% Test Coverage requirement
- Build Success enforcement
- Automatic retry and developer alert procedures

**Failure to follow this process will result in rework.**

---

**Technical Context Created:** 2025-10-29  
**Last Updated:** 2025-10-29  
**Next Story:** 1.5-3 - Service Mode Implementation

### References

- **ğŸ”´ MANDATORY PROCESS:** [BEFORE_YOU_CODE.md](../../BEFORE_YOU_CODE.md)
- **Knowledge Base:** [.dev/README.md](../../.dev/README.md) - Search spikes, bugs, findings, decisions
