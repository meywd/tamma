# Story 1.5-2: CLI Mode Enhancement

**Epic:** 1.5 - Deployment, Packaging & Operations  
**Status:** Ready for Development  
**Priority:** MVP Critical  
**Estimated Effort:** 4 days

## Overview

Enhance the CLI user experience with better prompts, progress tracking, color-coded output, enhanced error handling with actionable suggestions, and a configuration wizard. The CLI should provide an intuitive interactive experience for developers using Tamma directly from their terminal.

## Technical Context

### ⚠️ Development Process Reminder

**Before implementing this story, ensure you have:**
1. ✅ Read [BEFORE_YOU_CODE.md](../../BEFORE_YOU_CODE.md)
2. ✅ Searched `.dev/` directory for related spikes, bugs, findings, and decisions
3. ✅ Reviewed relevant documentation in `docs/` directory
4. ✅ Checked existing code patterns for similar functionality
5. ✅ Planned TDD approach (Red-Green-Refactor cycle)


This story builds upon the basic CLI scaffolding from Epic 1 Story 1-9 and the core engine separation from Story 1.5-1. The enhanced CLI will use the `@tamma/core` package for workflow execution while providing a rich interactive experience using modern CLI libraries like `@inquirer/prompts`, `ora`, and `chalk`.

The CLI must maintain the same workflow logic as other deployment modes while providing human-friendly interactions, progress indicators, and helpful error messages with actionable resolution suggestions.

## Acceptance Criteria

1. CLI startup displays branded banner with version number
2. Interactive issue selection with fuzzy search and preview
3. Progress indicators (spinners) for long-running operations (analysis, code generation)
4. Color-coded output (errors in red, success in green, warnings in yellow)
5. Enhanced error messages with actionable suggestions for resolution
6. `--debug` flag enables verbose logging to file
7. Configuration wizard (`tamma init`) creates config file interactively
8. Unit tests validate CLI command parsing and output formatting
9. Integration tests validate end-to-end CLI workflows

## Implementation Details

### CLI Package Structure

```
packages/
├── cli/                     # @tamma/cli - CLI launch wrapper
│   ├── src/
│   │   ├── commands/        # CLI commands
│   │   │   ├── run.ts       # Main workflow command
│   │   │   ├── init.ts      # Configuration wizard
│   │   │   ├── config.ts    # Config management
│   │   │   ├── status.ts    # Show current status
│   │   │   └── index.ts
│   │   ├── prompts/         # Interactive prompts
│   │   │   ├── issue-selection.ts
│   │   │   ├── plan-approval.ts
│   │   │   ├── config-wizard.ts
│   │   │   └── index.ts
│   │   ├── ui/              # UI components
│   │   │   ├── spinner.ts
│   │   │   ├── banner.ts
│   │   │   ├── colors.ts
│   │   │   └── index.ts
│   │   ├── utils/           # CLI utilities
│   │   │   ├── error-handler.ts
│   │   │   ├── logger.ts
│   │   │   ├── formatter.ts
│   │   │   └── index.ts
│   │   ├── index.ts         # CLI entry point
│   │   └── bin.ts           # Shebang executable
│   ├── tests/
│   │   ├── commands/
│   │   ├── prompts/
│   │   └── integration/
│   ├── package.json
│   └── tsconfig.json
```

### Main CLI Entry Point

```typescript
// @tamma/cli/src/index.ts
#!/usr/bin/env node

import { Command } from 'commander';
import chalk from 'chalk';
import { showBanner } from './ui/banner';
import { runCommand } from './commands/run';
import { initCommand } from './commands/init';
import { configCommand } from './commands/config';
import { statusCommand } from './commands/status';
import { createCLILogger } from './utils/logger';
import { loadConfig } from '@tamma/config';

const program = new Command();

async function main() {
  // Show banner for all commands except --help and --version
  if (!process.argv.includes('--help') && !process.argv.includes('--version')) {
    showBanner();
  }

  program
    .name('tamma')
    .description('AI-powered autonomous development orchestration')
    .version(getVersion());

  program
    .command('run')
    .description('Run autonomous development workflow')
    .option('-i, --issue <number>', 'Specific issue number to work on')
    .option('-c, --config <path>', 'Path to configuration file')
    .option('-d, --debug', 'Enable debug logging')
    .option('--no-interactive', 'Run in non-interactive mode')
    .action(runCommand);

  program
    .command('init')
    .description('Initialize Tamma configuration')
    .option('-f, --force', 'Overwrite existing configuration')
    .action(initCommand);

  program
    .command('config')
    .description('Manage configuration')
    .option('--show', 'Show current configuration')
    .option('--validate', 'Validate configuration')
    .action(configCommand);

  program
    .command('status')
    .description('Show current Tamma status')
    .action(statusCommand);

  await program.parseAsync();
}

main().catch(error => {
  console.error(chalk.red('❌ Fatal error:'), error.message);
  if (process.env.DEBUG) {
    console.error(error.stack);
  }
  process.exit(1);
});
```

### Branded Banner

```typescript
// @tamma/cli/src/ui/banner.ts
import chalk from 'chalk';
import figlet from 'figlet';

export function showBanner(): void {
  const logo = figlet.textSync('Tamma', {
    font: 'Standard',
    horizontalLayout: 'default',
    verticalLayout: 'default',
  });

  console.log(chalk.cyan(logo));
  console.log(chalk.gray('AI-powered autonomous development orchestration'));
  console.log(chalk.gray(`Version: ${getVersion()}`));
  console.log(); // Empty line for spacing
}

function getVersion(): string {
  try {
    const packageJson = require('../../package.json');
    return packageJson.version;
  } catch {
    return 'unknown';
  }
}
```

### Enhanced Run Command

```typescript
// @tamma/cli/src/commands/run.ts
import chalk from 'chalk';
import ora, { Ora } from 'ora';
import { select, confirm } from '@inquirer/prompts';
import { createEngine } from '@tamma/core';
import { loadConfig } from '@tamma/config';
import { createCLILogger } from '../utils/logger';
import { handleCLIError } from '../utils/error-handler';
import { promptIssueSelection } from '../prompts/issue-selection';
import { promptPlanApproval } from '../prompts/plan-approval';
import { formatPlan, formatIssue, formatTestResults } from '../utils/formatter';

interface RunOptions {
  issue?: string;
  config?: string;
  debug?: boolean;
  interactive?: boolean;
}

export async function runCommand(options: RunOptions): Promise<void> {
  const spinner = ora('Initializing Tamma...').start();

  try {
    // Load configuration
    const config = await loadConfig(options.config);
    const logger = createCLILogger(options.debug || false);

    // Create and initialize engine
    const engine = await createEngine({ mode: 'cli', config, logger });
    await engine.initialize();

    spinner.succeed('Tamma initialized successfully');

    // Issue selection
    let issue;
    if (options.issue) {
      spinner.start('Fetching specified issue...');
      issue = await engine.selectIssue({ number: parseInt(options.issue) });
      spinner.succeed(`Issue #${issue?.number} loaded`);
    } else if (options.interactive) {
      spinner.start('Fetching available issues...');
      const issues = await engine.selectIssue({ limit: 20, state: 'open' });
      spinner.succeed(`Found ${issues.length} issues`);

      issue = await promptIssueSelection(issues);
    } else {
      spinner.start('Selecting best issue...');
      issue = await engine.selectIssue({ limit: 1, state: 'open' });
      spinner.succeed(`Auto-selected issue #${issue?.number}`);
    }

    if (!issue) {
      console.log(chalk.yellow('No suitable issues found.'));
      return;
    }

    console.log(chalk.blue(`\n📋 Working on: ${issue.title} (#${issue.number})\n`));
    console.log(formatIssue(issue));

    // Issue analysis
    const analysisSpinner = ora('Analyzing issue complexity...').start();
    const analysis = await engine.analyzeIssue(issue);
    analysisSpinner.succeed(`Analysis complete: ${analysis.complexity} complexity`);

    console.log(chalk.gray(`\n📊 Analysis Summary:`));
    console.log(chalk.gray(`   Complexity: ${analysis.complexity}`));
    console.log(chalk.gray(`   Estimated effort: ${analysis.estimatedEffort} hours`));
    console.log(chalk.gray(`   Risk level: ${analysis.riskLevel}`));

    // Plan generation
    const planSpinner = ora('Generating development plan...').start();
    const plan = await engine.generatePlan(analysis);
    planSpinner.succeed('Development plan ready');

    // Show plan and get approval
    console.log('\n📝 Proposed Development Plan:\n');
    console.log(formatPlan(plan));

    if (options.interactive) {
      const approved = await promptPlanApproval(plan);
      if (!approved) {
        console.log(chalk.yellow('Plan rejected. Exiting.'));
        return;
      }
    } else {
      console.log(chalk.green('\n✅ Plan auto-approved (non-interactive mode)'));
    }

    // Execute plan with progress tracking
    await executePlanWithProgress(engine, plan);

    console.log(chalk.green(`\n🎉 Workflow completed successfully!\n`));
  } catch (error) {
    spinner.fail('Error occurred');
    handleCLIError(error, config);
  }
}

async function executePlanWithProgress(engine: any, plan: any): Promise<void> {
  const steps = [
    { name: 'Creating branch', action: () => engine.createBranch(plan) },
    { name: 'Implementing code', action: () => engine.implementCode(plan) },
    { name: 'Running tests', action: () => engine.runTests() },
    { name: 'Creating pull request', action: () => engine.createPullRequest() },
  ];

  for (const step of steps) {
    const spinner = ora(step.name).start();

    try {
      const result = await step.action();

      if (step.name === 'Running tests') {
        spinner.succeed(`Tests passed: ${result.passed}/${result.total}`);
        console.log(formatTestResults(result));
      } else {
        spinner.succeed(`${step.name} completed`);
      }
    } catch (error) {
      spinner.fail(`${step.name} failed`);
      throw error;
    }
  }
}
```

### Interactive Issue Selection

```typescript
// @tamma/cli/src/prompts/issue-selection.ts
import { select } from '@inquirer/prompts';
import chalk from 'chalk';
import { Issue } from '@tamma/shared';

export async function promptIssueSelection(issues: Issue[]): Promise<Issue> {
  if (issues.length === 0) {
    throw new Error('No issues available for selection');
  }

  const choices = issues.map((issue) => ({
    name: `#${issue.number}: ${issue.title}`,
    value: issue.number,
    description: `${chalk.gray(issue.labels.join(', '))} - ${chalk.cyan(`Priority: ${issue.priority}`)}`,
  }));

  const answer = await select({
    message: 'Select an issue to work on:',
    choices,
    pageSize: 10,
  });

  const selectedIssue = issues.find((i) => i.number === answer);
  if (!selectedIssue) {
    throw new Error('Selected issue not found');
  }

  return selectedIssue;
}
```

### Plan Approval Prompt

```typescript
// @tamma/cli/src/prompts/plan-approval.ts
import { confirm } from '@inquirer/prompts';
import chalk from 'chalk';
import { DevelopmentPlan } from '@tamma/shared';

export async function promptPlanApproval(plan: DevelopmentPlan): Promise<boolean> {
  console.log(chalk.yellow('\n⚠️  Review the plan carefully before approval:'));
  console.log(chalk.gray('   • This will create a new branch and implement changes'));
  console.log(chalk.gray('   • Tests will be run and a pull request will be created'));
  console.log(chalk.gray('   • You can always review and modify the PR before merging\n'));

  const approved = await confirm({
    message: 'Do you approve this development plan?',
    default: false,
  });

  return approved;
}
```

### Configuration Wizard

```typescript
// @tamma/cli/src/commands/init.ts
import chalk from 'chalk';
import { input, password, select, confirm } from '@inquirer/prompts';
import { writeFileSync } from 'fs';
import { join } from 'path';
import { homedir } from 'os';
import { ensureDirSync } from 'fs-extra';

interface InitOptions {
  force?: boolean;
}

export async function initCommand(options: InitOptions): Promise<void> {
  console.log(chalk.blue("🚀 Welcome to Tamma! Let's configure your setup.\n"));

  const configDir = join(homedir(), '.tamma');
  const configFile = join(configDir, 'config.yaml');

  // Check if config already exists
  if (!options.force && require('fs').existsSync(configFile)) {
    console.log(chalk.yellow('⚠️  Configuration file already exists:'));
    console.log(chalk.gray(`   ${configFile}`));

    const overwrite = await confirm({
      message: 'Do you want to overwrite it?',
      default: false,
    });

    if (!overwrite) {
      console.log(chalk.gray('Configuration initialization cancelled.'));
      return;
    }
  }

  // Create config directory
  ensureDirSync(configDir);

  // Gather configuration
  const config = await gatherConfiguration();

  // Write configuration file
  const yamlContent = generateYAMLConfig(config);
  writeFileSync(configFile, yamlContent, 'utf-8');

  console.log(chalk.green('\n✅ Configuration saved successfully!'));
  console.log(chalk.gray(`   File: ${configFile}`));
  console.log(chalk.gray('\nNext steps:'));
  console.log(chalk.gray('   1. Set your environment variables (API keys, tokens)'));
  console.log(chalk.gray('   2. Run "tamma run" to start your first workflow'));
}

async function gatherConfiguration(): Promise<any> {
  const config: any = {
    mode: 'cli',
    logLevel: 'info',
  };

  // AI Provider configuration
  console.log(chalk.cyan('🤖 AI Provider Configuration'));
  const aiProvider = await select({
    message: 'Select your preferred AI provider:',
    choices: [
      { name: 'Anthropic Claude', value: 'anthropic-claude' },
      { name: 'OpenAI GPT', value: 'openai' },
      { name: 'GitHub Copilot', value: 'github-copilot' },
      { name: 'Google Gemini', value: 'google-gemini' },
    ],
  });

  config.aiProvider = {
    default: aiProvider,
    providers: [
      {
        name: aiProvider,
        enabled: true,
        apiKey: '${' + aiProvider.toUpperCase().replace('-', '_') + '_API_KEY}',
      },
    ],
  };

  // Git Platform configuration
  console.log(chalk.cyan('\n🔧 Git Platform Configuration'));
  const gitPlatform = await select({
    message: 'Select your Git platform:',
    choices: [
      { name: 'GitHub', value: 'github' },
      { name: 'GitLab', value: 'gitlab' },
      { name: 'Bitbucket', value: 'bitbucket' },
    ],
  });

  config.gitPlatform = {
    default: gitPlatform,
    platforms: [
      {
        name: gitPlatform,
        enabled: true,
        token: '${' + gitPlatform.toUpperCase() + '_TOKEN}',
      },
    ],
  };

  // Workflow preferences
  console.log(chalk.cyan('\n⚙️  Workflow Preferences'));
  config.workflow = {
    autoApproveLowComplexity: await confirm({
      message: 'Auto-approve low complexity issues?',
      default: true,
    }),
    requireTests: await confirm({
      message: 'Require tests for all changes?',
      default: true,
    }),
    maxRetries: 3,
  };

  return config;
}

function generateYAMLConfig(config: any): string {
  // Simple YAML generator (in production, use a proper YAML library)
  return `# Tamma Configuration
mode: ${config.mode}
logLevel: ${config.logLevel}

aiProvider:
  default: ${config.aiProvider.default}
  providers:
    - name: ${config.aiProvider.providers[0].name}
      enabled: true
      apiKey: ${config.aiProvider.providers[0].apiKey}

gitPlatform:
  default: ${config.gitPlatform.default}
  platforms:
    - name: ${config.gitPlatform.platforms[0].name}
      enabled: true
      token: ${config.gitPlatform.platforms[0].token}

workflow:
  autoApproveLowComplexity: ${config.workflow.autoApproveLowComplexity}
  requireTests: ${config.workflow.requireTests}
  maxRetries: ${config.workflow.maxRetries}
`;
}
```

### Enhanced Error Handler

```typescript
// @tamma/cli/src/utils/error-handler.ts
import chalk from 'chalk';
import { TammaError } from '@tamma/core';

export function handleCLIError(error: any, config?: any): void {
  console.error(chalk.red('\n❌ An error occurred:'), error.message);

  // Provide actionable suggestions based on error type
  if (error instanceof TammaError) {
    switch (error.code) {
      case 'AI_PROVIDER_ERROR':
        console.error(chalk.yellow('\n💡 Suggestion: Check your AI provider configuration'));
        console.error(chalk.gray('   • Verify API key is set and valid'));
        console.error(chalk.gray('   • Check provider service status'));
        console.error(chalk.gray('   • Run "tamma config --show" to review configuration'));
        break;

      case 'GIT_PLATFORM_ERROR':
        console.error(chalk.yellow('\n💡 Suggestion: Check your Git platform configuration'));
        console.error(chalk.gray('   • Verify access token has required permissions'));
        console.error(chalk.gray('   • Check repository access and permissions'));
        console.error(chalk.gray('   • Ensure token is not expired'));
        break;

      case 'CONFIGURATION_ERROR':
        console.error(chalk.yellow('\n💡 Suggestion: Fix configuration issues'));
        console.error(chalk.gray('   • Run "tamma config --validate" to check configuration'));
        console.error(chalk.gray('   • Use "tamma init" to recreate configuration'));
        console.error(chalk.gray('   • Check environment variables are set'));
        break;

      case 'WORKFLOW_EXECUTION_FAILED':
        console.error(chalk.yellow('\n💡 Suggestion: Check workflow state and inputs'));
        console.error(chalk.gray('   • Verify issue exists and is accessible'));
        console.error(chalk.gray('   • Check repository is in a clean state'));
        console.error(chalk.gray('   • Review workflow logs for details'));
        break;

      default:
        console.error(chalk.yellow('\n💡 Suggestion: Run with --debug for detailed logs'));
        console.error(chalk.gray('   • Check the error context above'));
        console.error(chalk.gray('   • Report the issue if it persists'));
    }
  } else {
    // Generic error handling
    console.error(chalk.yellow('\n💡 General suggestions:'));
    console.error(chalk.gray('   • Run with --debug flag for more information'));
    console.error(chalk.gray('   • Check your internet connection'));
    console.error(chalk.gray('   • Verify all required environment variables are set'));
  }

  // Show debug information if available
  if (process.env.DEBUG && error.stack) {
    console.error(chalk.gray('\n📋 Debug information:'));
    console.error(chalk.gray(error.stack));
  }

  process.exit(1);
}
```

### CLI Logger

```typescript
// @tamma/cli/src/utils/logger.ts
import pino from 'pino';
import { writeFileSync, existsSync, mkdirSync } from 'fs';
import { join } from 'path';
import { homedir } from 'os';

export function createCLILogger(debug: boolean = false): pino.Logger {
  const logDir = join(homedir(), '.tamma', 'logs');

  if (!existsSync(logDir)) {
    mkdirSync(logDir, { recursive: true });
  }

  const logFile = join(logDir, `tamma-${new Date().toISOString().split('T')[0]}.log`);

  const logger = pino(
    {
      level: debug ? 'debug' : 'info',
      transport: debug
        ? {
            target: 'pino-pretty',
            options: {
              colorize: true,
              translateTime: 'HH:MM:ss Z',
              ignore: 'pid,hostname',
            },
          }
        : undefined,
    },
    debug ? pino.destination(logFile) : process.stdout
  );

  return logger;
}
```

### Output Formatters

```typescript
// @tamma/cli/src/utils/formatter.ts
import chalk from 'chalk';
import { Issue, DevelopmentPlan, TestResults } from '@tamma/shared';

export function formatIssue(issue: Issue): string {
  let output = '';

  output += chalk.gray(`   State: ${issue.state}\n`);
  output += chalk.gray(`   Labels: ${issue.labels.join(', ') || 'None'}\n`);
  output += chalk.gray(`   Priority: ${issue.priority}\n`);
  output += chalk.gray(`   Assignee: ${issue.assignee || 'Unassigned'}\n`);
  output += chalk.gray(`   Created: ${new Date(issue.createdAt).toLocaleDateString()}\n`);

  if (issue.body) {
    output += chalk.gray(`\n   Description:\n`);
    output += chalk.gray(`   ${issue.body.split('\n').slice(0, 3).join('\n   ')}`);
    if (issue.body.split('\n').length > 3) {
      output += chalk.gray('\n   ...');
    }
  }

  return output;
}

export function formatPlan(plan: DevelopmentPlan): string {
  let output = '';

  output += chalk.cyan(`   Estimated Time: ${plan.estimatedHours} hours\n`);
  output += chalk.cyan(`   Complexity: ${plan.complexity}\n`);
  output += chalk.cyan(`   Risk Level: ${plan.riskLevel}\n\n`);

  output += chalk.white('   Steps:\n');
  plan.steps.forEach((step, index) => {
    const status = step.completed ? chalk.green('✓') : chalk.gray('○');
    output += `   ${status} ${index + 1}. ${step.description}\n`;
    if (step.estimatedTime) {
      output += chalk.gray(`      Estimated: ${step.estimatedTime} minutes\n`);
    }
  });

  return output;
}

export function formatTestResults(results: TestResults): string {
  let output = '';

  if (results.passed) {
    output += chalk.green(`   ✓ ${results.passed} tests passed`);
  }

  if (results.failed) {
    output += chalk.red(`   ✗ ${results.failed} tests failed`);
  }

  if (results.skipped) {
    output += chalk.yellow(`   ○ ${results.skipped} tests skipped`);
  }

  output += chalk.gray(` (${results.total} total)\n`);

  if (results.coverage) {
    output += chalk.gray(`   Coverage: ${results.coverage}%\n`);
  }

  return output;
}
```

## Testing Strategy

### Unit Tests

```typescript
// @tamma/cli/tests/commands/run.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { runCommand } from '../../../src/commands/run';
import { createEngine } from '@tamma/core';

vi.mock('@tamma/core');
vi.mock('@inquirer/prompts');

describe('runCommand', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should execute workflow with specified issue', async () => {
    const mockEngine = {
      initialize: vi.fn(),
      selectIssue: vi.fn().mockResolvedValue({ number: 123, title: 'Test Issue' }),
      analyzeIssue: vi.fn().mockResolvedValue({ complexity: 'low' }),
      generatePlan: vi.fn().mockResolvedValue({ steps: [] }),
      createBranch: vi.fn(),
      implementCode: vi.fn(),
      runTests: vi.fn().mockResolvedValue({ passed: true, total: 10 }),
      createPullRequest: vi.fn(),
    };

    vi.mocked(createEngine).mockResolvedValue(mockEngine);

    await runCommand({
      issue: '123',
      interactive: false,
      debug: false,
    });

    expect(mockEngine.selectIssue).toHaveBeenCalledWith({ number: 123 });
    expect(mockEngine.analyzeIssue).toHaveBeenCalled();
    expect(mockEngine.generatePlan).toHaveBeenCalled();
  });

  it('should handle interactive mode with prompts', async () => {
    // Test interactive prompt handling
  });

  it('should handle errors gracefully', async () => {
    const mockEngine = {
      initialize: vi.fn().mockRejectedValue(new Error('Test error')),
    };

    vi.mocked(createEngine).mockResolvedValue(mockEngine);

    await expect(runCommand({ interactive: false })).rejects.toThrow();
  });
});
```

### Integration Tests

```typescript
// @tamma/cli/tests/integration/end-to-end.test.ts
import { describe, it, expect } from 'vitest';
import { execSync } from 'child_process';
import { existsSync, unlinkSync } from 'fs';
import { join } from 'path';

describe('CLI Integration Tests', () => {
  const testConfigPath = join(__dirname, 'test-config.yaml');

  afterEach(() => {
    if (existsSync(testConfigPath)) {
      unlinkSync(testConfigPath);
    }
  });

  it('should show help information', () => {
    const result = execSync('node packages/cli/src/bin.js --help', {
      encoding: 'utf-8',
    });

    expect(result).toContain('AI-powered autonomous development');
    expect(result).toContain('run');
    expect(result).toContain('init');
  });

  it('should initialize configuration', () => {
    const result = execSync(`node packages/cli/src/bin.js init --force`, {
      encoding: 'utf-8',
      cwd: __dirname,
    });

    expect(result).toContain('Configuration saved successfully');
    expect(existsSync(join(__dirname, '.tamma', 'config.yaml'))).toBe(true);
  });

  it('should validate configuration', () => {
    execSync('node packages/cli/src/bin.js init --force', {
      cwd: __dirname,
    });

    const result = execSync('node packages/cli/src/bin.js config --validate', {
      encoding: 'utf-8',
      cwd: __dirname,
    });

    expect(result).toContain('Configuration is valid');
  });
});
```

## Dependencies

### Package Dependencies

```json
{
  "name": "@tamma/cli",
  "version": "1.0.0",
  "description": "Tamma CLI - interactive command-line interface",
  "main": "dist/index.js",
  "bin": {
    "tamma": "dist/bin.js"
  },
  "scripts": {
    "build": "tsc",
    "test": "vitest",
    "dev": "tsx src/index.ts"
  },
  "dependencies": {
    "@tamma/core": "workspace:*",
    "@tamma/config": "workspace:*",
    "@inquirer/prompts": "^5.0.0",
    "commander": "^12.0.0",
    "ora": "^8.0.0",
    "chalk": "^5.3.0",
    "figlet": "^1.7.0",
    "pino": "^9.0.0",
    "pino-pretty": "^11.0.0",
    "fs-extra": "^11.2.0"
  },
  "devDependencies": {
    "@types/node": "^22.0.0",
    "@types/figlet": "^1.5.8",
    "@types/fs-extra": "^11.0.4",
    "typescript": "^5.7.0",
    "tsx": "^4.11.0",
    "vitest": "^2.0.0"
  }
}
```

## Performance Considerations

1. **Startup Time**: CLI should start in <2 seconds
2. **Interactive Responsiveness**: Prompts should respond in <100ms
3. **Memory Usage**: Keep CLI memory footprint <100MB
4. **Progress Updates**: Provide frequent progress feedback for long operations

## Security Considerations

1. **Input Validation**: Validate all user inputs
2. **Credential Protection**: Never log or expose API keys
3. **File Permissions**: Secure config file permissions (600)
4. **Command Injection**: Prevent command injection in user inputs

## Accessibility

1. **Color Support**: Respect NO_COLOR environment variable
2. **Screen Readers**: Provide text-only output options
3. **Keyboard Navigation**: Full keyboard support in prompts
4. **Error Messages**: Clear, actionable error descriptions

## Success Metrics

1. **User Experience**: User satisfaction score >4.5/5
2. **Error Recovery**: >90% of errors have actionable suggestions
3. **Performance**: CLI startup <2 seconds, prompt response <100ms
4. **Adoption**: >80% of users successfully complete init wizard
5. **Support**: <5% of users require support for basic CLI usage

---

## ⚠️ MANDATORY: Before You Code

**ALL contributors MUST read and follow the comprehensive development process:**

📖 **[BEFORE_YOU_CODE.md](../../BEFORE_YOU_CODE.md)**

This mandatory guide includes:
- 7-Phase Development Workflow (Read → Research → Break Down → TDD → Quality Gates → Failure Handling)
- Knowledge Base Usage (.dev/ directory: spikes, bugs, findings, decisions)
- TRACE/DEBUG Logging Requirements for all functions
- Test-Driven Development (TDD) mandatory workflow
- 100% Test Coverage requirement
- Build Success enforcement
- Automatic retry and developer alert procedures

**Failure to follow this process will result in rework.**

---

**Technical Context Created:** 2025-10-29  
**Last Updated:** 2025-10-29  
**Next Story:** 1.5-3 - Service Mode Implementation

### References

- **🔴 MANDATORY PROCESS:** [BEFORE_YOU_CODE.md](../../BEFORE_YOU_CODE.md)
- **Knowledge Base:** [.dev/README.md](../../.dev/README.md) - Search spikes, bugs, findings, decisions
